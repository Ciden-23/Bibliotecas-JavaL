
import java.awt.Dimension;
import java.awt.Image;
import java.awt.Toolkit;

/**
 *
 * @author Brayan Garcia Version 1.0
 */
public class Ventana extends javax.swing.JFrame {

    private static final String ver = "1.0.1";

    /**
     * Crea un nuevo JFrame. Haciendo uso de la clase Toolkit obtenemos el
     * tamaño de pantalla y colocamos la ventana al centro. Colocamos la
     * visibilidad de los componentes en false.
     */
    public Ventana() {
        javax.swing.JOptionPane.showMessageDialog(null, "Bienvenida Pandita ^~^", "Bibliotecas Java Lite", javax.swing.JOptionPane.PLAIN_MESSAGE);
        initComponents();
        Toolkit t = Toolkit.getDefaultToolkit();
        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
        int ancho = java.awt.Toolkit.getDefaultToolkit().getScreenSize().width;
        int alto = java.awt.Toolkit.getDefaultToolkit().getScreenSize().height;
        setLocation((ancho / 2) - (this.getWidth() / 2), (alto / 2) - (this.getHeight() / 2));
        setSize(655, 420);
        jComboBox2.setVisible(false);
        jComboBox3.setVisible(false);
        jScrollPane1.setVisible(false);
        jTextArea1.setVisible(false);

    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        jComboBox1 = new javax.swing.JComboBox<>();
        jComboBox2 = new javax.swing.JComboBox<>();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();
        jLabel1 = new javax.swing.JLabel();
        jComboBox3 = new javax.swing.JComboBox<>();
        jButton1 = new javax.swing.JButton();
        jButton2 = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Bibliotecas Java Lite");
        setIconImage(getIconImage());
        setResizable(false);

        jPanel1.setBackground(new java.awt.Color(204, 255, 255));
        jPanel1.setPreferredSize(new java.awt.Dimension(655, 410));

        jComboBox1.setBackground(new java.awt.Color(204, 204, 204));
        jComboBox1.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "Selecciona una biblioteca", "java.lang", "java.util" }));
        jComboBox1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jComboBox1ActionPerformed(evt);
            }
        });

        jComboBox2.setBackground(new java.awt.Color(204, 204, 204));
        jComboBox2.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "Relleno" }));
        jComboBox2.setToolTipText("");
        jComboBox2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jComboBox2ActionPerformed(evt);
            }
        });

        jTextArea1.setEditable(false);
        jTextArea1.setBackground(new java.awt.Color(51, 51, 51));
        jTextArea1.setColumns(20);
        jTextArea1.setForeground(new java.awt.Color(255, 255, 255));
        jTextArea1.setRows(5);
        jTextArea1.setBorder(javax.swing.BorderFactory.createMatteBorder(1, 1, 1, 1, new java.awt.Color(255, 255, 255)));
        jScrollPane1.setViewportView(jTextArea1);

        jLabel1.setFont(new java.awt.Font("Tahoma", 1, 12)); // NOI18N

        jComboBox3.setBackground(new java.awt.Color(204, 204, 204));
        jComboBox3.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "Relleno" }));
        jComboBox3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jComboBox3ActionPerformed(evt);
            }
        });

        jButton1.setText("Versión");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jButton2.setText("=^~^=");
        jButton2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton2ActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jButton2, javax.swing.GroupLayout.PREFERRED_SIZE, 80, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(28, 28, 28)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(jLabel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jComboBox3, 0, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jComboBox1, 0, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jComboBox2, javax.swing.GroupLayout.Alignment.LEADING, 0, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 445, Short.MAX_VALUE))
                .addGap(18, 18, 18)
                .addComponent(jButton1)
                .addGap(7, 7, 7))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGap(40, 40, 40)
                        .addComponent(jComboBox1, javax.swing.GroupLayout.PREFERRED_SIZE, 29, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGap(21, 21, 21)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jButton1)
                            .addComponent(jButton2))))
                .addGap(18, 18, 18)
                .addComponent(jComboBox2, javax.swing.GroupLayout.PREFERRED_SIZE, 29, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(jComboBox3, javax.swing.GroupLayout.PREFERRED_SIZE, 29, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 29, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 140, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(52, Short.MAX_VALUE))
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, 420, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * Metodo void que comprueba el valor seleccionado en el JComboBox1.
     * Posterior a eso llama al metodo cambioItem y asigna valores a varios
     * componentes.
     */
    private void jComboBox1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jComboBox1ActionPerformed
        // TODO add your handling code here:
        switch (jComboBox1.getSelectedItem().toString()) {
            case "java.lang":
                cambioItem((byte) 0);
                jComboBox2.setVisible(true);
                jTextArea1.setText("");
                jTextArea1.append("Provee clases que son fundamentales para el diseño \nde la programacion en Java.");
                jLabel1.setText("Biblioteca");
                jTextArea1.setVisible(true);
                jScrollPane1.setVisible(true);
                break;
            case "java.util":
                cambioItem((byte) 1);
                jComboBox2.setVisible(true);
                jTextArea1.setText("");
                jTextArea1.append("Contiene las colecciones del framework, clases de \ncolecciones legadas, "
                        + "modelo de eventos, \nutilidades de fecha y hora, "
                        + "internacionalizacion, y miscelanea \nde clases utilitarias (un string tokenizer,"
                        + " \nun generador de numeros-aleatorios, y un arreglo de bits).");
                jLabel1.setText("Biblioteca");
                jTextArea1.setVisible(true);
                jScrollPane1.setVisible(true);
                break;
            case "Selecciona una biblioteca":
                jTextArea1.setText("");
                jLabel1.setText("");
                jComboBox2.setVisible(false);
                jComboBox3.setVisible(false);
                jScrollPane1.setVisible(false);
                jTextArea1.setVisible(false);
                break;
        }
    }//GEN-LAST:event_jComboBox1ActionPerformed

    /**
     * Coloca un modelo especifico al JComboBox2 dependiendo del valor asignado.
     *
     * @param n - El valor recibido para seleccionar un modelo especifico.
     */
    private void cambioItem(byte n) {
        switch (n) {
            case 0:
                jComboBox2.setModel(new javax.swing.DefaultComboBoxModel<>(new String[]{"Selecciona una clase", "java.lang.Boolean", "java.lang.Byte",
                    "java.lang.Character", "java.lang.Double", "java.lang.Float", "java.lang.Integer", "java.lang.Long", "java.lang.Math", "java.lang.Number",
                    "java.lang.Object", "java.lang.Short", "java.lang.String", "java.lang.Void"}));
                break;
            case 1:
                jComboBox2.setModel(new javax.swing.DefaultComboBoxModel<>(new String[]{"Selecciona una clase", "java.util.ArrayList<E>", "java.util.Arrays"}));
                break;
        }
    }

    /**
     * Metodo void que comprueba el valor seleccionado en el JComboBox2.
     * Posterior a eso llama al metodo de cambio de texto(Clases/Interfaces)
     * para que asigne valores a los componentes.
     */
    private void jComboBox2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jComboBox2ActionPerformed
        // TODO add your handling code here:
        switch (jComboBox1.getSelectedItem().toString()) {
            case "java.lang":
                cambiotextoLang();
                break;
            case "java.util":
                cambiotextoUtil();
                break;
        }
    }//GEN-LAST:event_jComboBox2ActionPerformed

    /**
     * Metodo void que comprueba el valor seleccionado en el JComboBox2.
     * Dependiendo del valor seleccionado llamara al metodo cambioMetodoL()
     * enviandole un valor en especial. Asignara valores a los componentes y le
     * dara/quitara visibilidad al JComboBox3.
     */
    private void cambiotextoLang() {
        switch (jComboBox2.getSelectedItem().toString()) {
            case "Selecciona una clase":
                jTextArea1.setText("");
                jLabel1.setText("");
                jComboBox3.setVisible(false);
                break;
            case "java.lang.Boolean":
                jTextArea1.setText("");
                jTextArea1.append("Almacena un valor primitivo boolean en un objeto.\nSin algun método util/destacable.\n");
                jTextArea1.append("Su constructor es:\nBoolean(boolean value)\nConstruye un nuevo objeto Boolean que representa el valor dado.");
                jLabel1.setText("Clase Final");
                jComboBox3.setVisible(false);
                break;
            case "java.lang.Byte":
                cambioMetodoL((byte) 0);
                jComboBox3.setVisible(true);
                jTextArea1.setText("");
                jTextArea1.append("Almacena un valor primitivo byte en un objeto.");
                jLabel1.setText("Clase Final");
                break;
            case "java.lang.Character":
                cambioMetodoL((byte) 1);
                jComboBox3.setVisible(true);
                jTextArea1.setText("");
                jTextArea1.append("Almacena un valor primitivo char en un objeto.");
                jLabel1.setText("Clase Final");
                break;
            case "java.lang.Double":
                cambioMetodoL((byte) 2);
                jComboBox3.setVisible(true);
                jTextArea1.setText("");
                jTextArea1.append("Almacena un valor primitivo double en un objeto.");
                jLabel1.setText("Clase Final");
                break;
            case "java.lang.Float":
                cambioMetodoL((byte) 3);
                jComboBox3.setVisible(true);
                jTextArea1.setText("");
                jTextArea1.append("Almacena un valor primitivo float en un objeto.");
                jLabel1.setText("Clase Final");
                break;
            case "java.lang.Integer":
                cambioMetodoL((byte) 4);
                jComboBox3.setVisible(true);
                jTextArea1.setText("");
                jTextArea1.append("Almacena un valor primitivo int en un objeto.");
                jLabel1.setText("Clase Final");
                break;
            case "java.lang.Long":
                cambioMetodoL((byte) 5);
                jComboBox3.setVisible(true);
                jTextArea1.setText("");
                jTextArea1.append("Almacena un valor primitivo long en un objeto.");
                jLabel1.setText("Clase Final");
                break;
            case "java.lang.Math":
                cambioMetodoL((byte) 6);
                jComboBox3.setVisible(true);
                jTextArea1.setText("");
                jTextArea1.append("Contiene metodos para realizar operaciones numericas.");
                jLabel1.setText("Clase Final");
                break;
            case "java.lang.Number":
                cambioMetodoL((byte) 7);
                jComboBox3.setVisible(true);
                jTextArea1.setText("");
                jTextArea1.append("Es la superclase de la plataforma de clases que representan"
                        + " \nvalores numericos.");
                jLabel1.setText("Clase Abstracta");
                break;
            case "java.lang.Object":
                cambioMetodoL((byte) 8);
                jComboBox3.setVisible(true);
                jTextArea1.setText("");
                jTextArea1.append("Raiz de toda la jeraraquia de clases, toda clase tiene a la"
                        + " \n la clase Object como superclase.");
                jLabel1.setText("Clase");
                break;
            case "java.lang.Short":
                cambioMetodoL((byte) 9);
                jComboBox3.setVisible(true);
                jTextArea1.setText("");
                jTextArea1.append("Almacena un valor primitivo short en un objeto.");
                jLabel1.setText("Clase Final");
                break;
            case "java.lang.String":
                cambioMetodoL((byte) 10);
                jComboBox3.setVisible(true);
                jTextArea1.setText("");
                jTextArea1.append("Representa cadenas de caracteres, todas las cadenas literales"
                        + " \nen Java son implementadas como instancias de esta clase.");
                jLabel1.setText("Clase Final");
                break;
            case "java.lang.Void":
                jComboBox3.setVisible(true);
                jTextArea1.setText("");
                jTextArea1.append("Ininstanciable marcador de clase que representa a la palabra"
                        + " \nreservada de Java void.");
                jLabel1.setText("Clase Final");
                break;
        }
    }

    /**
     * Metodo void que dependiendo del valor recibido asignara un modelo
     * especifico al JComboBox3
     *
     * @param n - El valor recibido para seleccionar un modelo en especifico.
     */
    private void cambioMetodoL(byte n) {
        switch (n) {
            case 0:
                jComboBox3.setModel(new javax.swing.DefaultComboBoxModel<>(new String[]{"Selecciona un método", "-Constructor-", "byteValue()", "doubleValue()",
                    "equals(Object obj)", "floatValue()", "intValue()", "longValue()", "parseByte(String s)", "shortValue()", "toString()", "toString(byte b)", "valueOf(byte b)", "valueOf(String s)"
                }));
                break;
            case 1:
                jComboBox3.setModel(new javax.swing.DefaultComboBoxModel<>(new String[]{"Selecciona un método", "-Constructor-", "charValue()", "equals(Object obj)",
                    "isLetter(char ch)", "isLowerCase(char ch)", "isUpperCase(char ch)", "isWhitespace(char ch)", "toLowerCase(char ch)", "toString()", "toString(char c)", "toUpperCase(char ch)", "valueOf(char c)"
                }));
                break;
            case 2:
                jComboBox3.setModel(new javax.swing.DefaultComboBoxModel<>(new String[]{"Selecciona un método", "-Constructor-", "byteValue()", "doubleValue()",
                    "equals(Object obj)", "floatValue()", "intValue()", "isFinite(double d)", "isInfinite()", "isInfinite(double v)", "longValue()",
                    "parseDouble(String s)", "shortValue()", "toString()", "toString(float f)", "valueOf(double d)", "valueOf(String s)"}));
                break;
            case 3:
                jComboBox3.setModel(new javax.swing.DefaultComboBoxModel<>(new String[]{"Selecciona un método", "-Constructor-", "byteValue()", "doubleValue()",
                    "equals(Object obj)", "floatValue()", "intValue()", "isFinite(float f)", "isInfinite()", "isInfinite(float v)", "longValue()",
                    "parseFloat(String s)", "shortValue()", "toString()", "toString(double d)", "valueOf(float f)", "valueOf(String s)"}));
                break;
            case 4:
                jComboBox3.setModel(new javax.swing.DefaultComboBoxModel<>(new String[]{"Selecciona un método", "-Constructor-", "byteValue()", "doubleValue()",
                    "equals(Object obj)", "floatValue()", "intValue()", "longValue()", "parseInt(String s)", "parseUnsignedInt(String s)", "shortValue()",
                    "toBinaryString(int i)", "toHexString(int i)", "toOctalString(int i)", "toString()", "toString(int i)", "toUnsignedLong(int x)",
                    "toUnsignedString(int i)", "valueOf(int i)", "valueOf(String s)"}));
                break;
            case 5:
                jComboBox3.setModel(new javax.swing.DefaultComboBoxModel<>(new String[]{"Selecciona un método", "-Constructor-", "byteValue()", "doubleValue()",
                    "equals(Object obj)", "floatValue()", "intValue()", "longValue()", "parseLong(String s)", "parseUnsignedLong(String s)", "shortValue()",
                    "toBinaryString(long i)", "toHexString(long i)", "toOctalString(long i)", "toString()", "toString(long i)", "toUnsignedString(long i)",
                    "valueOf(long i)", "valueOf(String s)"}));
                break;
            case 6:
                jComboBox3.setModel(new javax.swing.DefaultComboBoxModel<>(new String[]{"Selecciona un método", "-Constantes-", "abs(double a)", "abs(float a)",
                    "abs(int a)", "abs(long a)", "acos(double a)", "asin(double a)", "atan(double a)", "atan2(double y,double x)", "cbrt(double a)", "ceil(double a)",
                    "copySign(double magnitude,double sign)", "copySign(float magnitude,float sign)", "cos(double a)", "cosh(double x)", "exp(double a)",
                    "expm1(double x)", "floor(double a)", "hypot(double x,double y)", "log(double a)", "log10(double a)", "log1p(double x)", "max(double a,double b)",
                    "max(float a,float b)", "max(int a,int b)", "max(long a,long b)", "min(double a,double b)", "min(float a,float b)", "min(int a,int b)", "min(long a,long b)",
                    "pow(double a,double b)", "random()", "rint(double a)", "round(double a)", "round(float a)", "sin(double a)", "sinh(double x)", "sqrt(double a)",
                    "tan(double a)", "tanh(double x)", "toDegrees(double angrad)", "toRadians(double angdeg)",}));
                break;
            case 7:
                jComboBox3.setModel(new javax.swing.DefaultComboBoxModel<>(new String[]{"Selecciona un método", "-Constructor-", "byteValue()", "doubleValue()",
                    "floatValue()", "intValue()", "longValue()", "shortValue()"}));
                break;
            case 8:
                jComboBox3.setModel(new javax.swing.DefaultComboBoxModel<>(new String[]{"Selecciona un método", "-Constructor-", "clone()", "equals(Object obj)", "toString()"}));
                break;
            case 9:
                jComboBox3.setModel(new javax.swing.DefaultComboBoxModel<>(new String[]{"Selecciona un método", "-Constructor-", "byteValue()", "doubleValue()",
                    "equals(Object obj)", "floatValue()", "intValue()", "longValue()", "parseShort(String s)", "shortValue()", "toString()", "toString(short s)",
                    "toUnsignedInt(short x)", "toUnsignedLong(short x)", "valueOf(short s)", "valueOf(String s)"}));
            case 10:
                jComboBox3.setModel(new javax.swing.DefaultComboBoxModel<>(new String[]{"Selecciona un método", "-Constructor-", "charAt(int index)", "compareTo(String anotherString)",
                    "compareToIgnoreCase(String str)", "concat(String str)", "contains(CharSecuence s)", "contentEquals(CharSequence cs)", "endsWith(String suffix)", "equals(Object anObject)",
                    "equalsIgnoreCase(String anotherString)", "getChars(int srcBegin,int srcEnd,char[] dst,int dstBegin)", "indexOf(String str)", "indexOf(String str,int fromIndex)", "isEmpty()", "lastIndexOf(String str)",
                    "lastIndexOf(String str,int fromIndex)", "length()", "regionMatches(boolean ignoreCase,int toffset,String other,int ooffset,int len)", "regionMatches(int toffset,String other,int ooffset,int len)",
                    "replace(char oldChar,char newChar)", "replace(CharSequence target,String replacement", "replaceAll(String regex,String replacement)", "replaceFirst(String regex,String replacement)",
                    "startsWith(String prefix)", "startsWith(String prefix,int toffset)", "substring(int beginIndex)", "substring(int beginIndex,int endIndex)", "toCharArray()",
                    "toLowerCase()", "toString()", "toUpperCase()", "trim()", "valueOf(boolean b)", "valueOf(char c)", "valueOf(char[] data)", "valueOf(char[] data,int offset,int count)",
                    "valueOf(double d)", "valueOf(float f)", "valueOf(int i)", "valueOf(long l)", "valueOf(Object obj)"}));
        }
    }

    /**
     * Metodo void que comprueba el valor seleccionado en el JComboBox2.
     * Dependiendo del valor seleccionado llamara al metodo cambioMetodoU()
     * enviandole un valor en especial. Asignara valores a los componentes y le
     * dara/quitara visibilidad al JComboBox3.
     */
    private void cambiotextoUtil() {
        switch (jComboBox2.getSelectedItem().toString()) {
            case "Selecciona una clase":
                jTextArea1.setText("");
                jLabel1.setText("");
                jComboBox3.setVisible(false);
                break;
            case "java.util.ArrayList<E>":
                cambioMetodoU((byte) 0);
                jComboBox3.setVisible(true);
                jTextArea1.setText("");
                jTextArea1.append("Arreglo redimensionable, implementacion del Interface List.\nImplementa todas las operaciones opcionales de una lista,"
                        + "\npermitiendo todos los elementos incluyendo null.");
                jLabel1.setText("Clase");
                break;
            case "java.util.Arrays":
                cambioMetodoU((byte) 1);
                jComboBox3.setVisible(true);
                jTextArea1.setText("");
                jTextArea1.append("Contiene varios metodos para manipular arreglos\n(como ordenamiento y busqueda) tambien incluye una fabrica que permite\n"
                        + "a los arreglos ser mostrados como listas.");
                jLabel1.setText("Clase");
                break;
        }
    }

    /**
     * Metodo void que dependiendo del valor recibido asignara un modelo
     * especifico al JComboBox3
     *
     * @param n - El valor recibido para seleccionar un modelo en especifico.
     */
    private void cambioMetodoU(byte n) {
        switch (n) {
            case 0:
                jComboBox3.setModel(new javax.swing.DefaultComboBoxModel<>(new String[]{"Selecciona un método", "-Constructor-", "add(E e)", "add(int index, E element)",
                    "addAll(Collection<? extends E> c)", "addAll(int index,Collection<? extends E> c)", "clear()", "clone()", "contains(Object o)", "ensureCapacity(int minCapacity)",
                    "get(int index)", "indexOf(Object o)", "isEmpty()", "lastIndexOf(Object o)", "remove(int index)", "remove(Object o)", "removeAll(Collection<?> c)",
                    "removeRange(int fromIndex,int toIndex)", "retainAll(Collection<?> c)", "set(int index E element)", "size()", "toArray()", "toArray(T[] a)", "trimToSize()"}));
                break;
            case 1:
                jComboBox3.setModel(new javax.swing.DefaultComboBoxModel<>(new String[]{"Selecciona un método", "asList(T... a)", "bynarySearch(byte[] a,byte key)", "bynarySearch(byte[] a,int fromIndex,int toIndex,byte key)",
                    "bynarySearch(char[] a,char key)", "bynarySearch(char[] a,int fromIndex,int toIndex,char key)", "bynarySearch(double[] a, double key)", "bynarySearch(double[] a,int fromIndex,int toIndex,double key)",
                    "bynarySearch(float[] a,float key)", "bynarySearch(float[] a,int fromIndex,int toIndex,float key)", "bynarySearch(int[] a,int key)", "bynarySearch(int a,int fromIndex,int toIndex,int key)",
                    "bynarySearch(long[]int fromIndex,int toIndex,long key)", "bynarySearch(long[] a,long key)", "bynarySearch(Object[] a,int fromIndex,int toIndex,Object key)", "bynarySearch(Object[] a,Object key)",
                    "bynarySearch(short[] a,int fromIndex,int toIndex,short key)", "bynarySearch(short[] a,short key)", "copyOf(boolean[] original,int newLength)", "copyOf(byte[] original,int newLength)", "copyOf(char[] original,int newLength)",
                    "copyOf(double[] original,int newLength)", "copyOf(float[] original,int newLength)", "copyOf(int[] original,int newLength)", "copyOf(long[] original,int newLength)", "copyOf(short[] original,int newLength)", "copyOf(T[] original,int newLength)",
                    "copyOfRange(boolean[] original,int from,int to)", "copyOfRange(byte[] original,,int from,int to)", "copyOfRange(char[] original,,int from,int to)", "copyOfRange(double[] original,,int from,int to)", "copyOfRange(float[] original,,int from,int to)",
                    "copyOfRange(int[] original,,int from,int to)", "copyOfRange(long[] original,,int from,int to)", "copyOfRange(short[] original,int from,int to)", "copyOfRange(T[] original,,int from,int to)", "deepEquals(Object[] a1,Object[] a2)", "equals(boolean[] a,boolean[] a2)",
                    "equals(byte[] a,byte[] a2)", "equals(char[] a,char[] a2)", "equals(double[] a,double[] a2)", "equals(float[] a,float[] a2)", "equals(int[] a,int[] a2)", "equals(long[] a,long[] a2)", "equals(Object[] a,Object[] a2)", "equals(short[] a,short[] a2)", "fill(boolean[] a,boolean val)",
                    "fill(boolean[] a,int fromIndex,int toIndex,boolean val)", "fill(byte[] a,byte val)", "fill(byte[] a,int fromIndex,int toIndex,byte val)", "fill(char[] a,char val)", "fill(char[] a,int fromIndex,int toIndex,char val)", "fill(double[] a,double val)",
                    "fill(double[] a,int fromIndex,int toIndex,double val)", "fill(float[] a,float val)", "fill(float[] a,int fromIndex,int toIndex,float val)", "fill(int[] a,int val)", "fill(int[] a,int fromIndex,int toIndex,int val)", "fill(long[] a,int fromIndex,int toIndex,long val)",
                    "fill(long[] a,long val)", "fill(Object[] a,int fromIndex,int toIndex,Object val)", "fill(Object[] a,Object val)", "fill(short[] a,int fromIndex,int toIndex,short val)", "fill(short[] a,short val)", "parallelSort(byte[] a)", "parallelSort(byte[] a,int fromIndex,int toIndex)", "parallelSort(char[] a)",
                    "parallelSort(char[] a,int fromIndex,int toIndex)", "parallelSort(double[] a)", "parallelSort(double[] a,int fromIndex,int toIndex)", "parallelSort(float[] a)", "parallelSort(float[] a,int fromIndex,int toIndex)", "parallelSort(int[] a)", "parallelSort(int[] a,int fromIndex,int toIndex)", "parallelSort(long[] a)", "parallelSort(long[] a,int fromIndex,int toIndex)",
                    "parallelSort(Object[] a)", "parallelSort(Object[] a,int fromIndex,int toIndex)", "parallelSort(short[] a)", "parallelSort(short[] a,int fromIndex,int toIndex)", "sort(byte[] a)", "sort(byte[] a,int fromIndex,int toIndex)", "sort(char[] a)",
                    "sort(char[] a,int fromIndex,int toIndex)", "sort(double[] a)", "sort(double[] a,int fromIndex,int toIndex)", "sort(float[] a)", "sort(float[] a,int fromIndex,int toIndex)", "sort(int[] a)", "sort(int[] a,int fromIndex,int toIndex)", "sort(long[] a)", "sort(long[] a,int fromIndex,int toIndex)",
                    "sort(Object[] a)", "sort(Object[] a,int fromIndex,int toIndex)", "sort(short[] a)", "sort(short[] a,int fromIndex,int toIndex)", "toString(boolean[] a)", "toString(byte[] a)", "toString(char[] a)", "toString(double[] a)", "toString(float[] a)", "toString(int[] a)",
                    "toString(long[] a)", "toString(Object[] a)", "toString(short[] a)"}));
                break;
        }
    }

    /**
     * Metodo void que comprueba el valor seleccionado en el JComboBox3.
     * Posterior a eso llama al metodo de cambio de texto(Metodos) para que
     * asigne valores a los componentes.
     */
    private void jComboBox3ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jComboBox3ActionPerformed
        // TODO add your handling code here:
        switch (jComboBox2.getSelectedItem().toString()) {
            case "java.lang.Byte":
                cambiotextoByte();
                break;
            case "java.lang.Character":
                cambiotextoChar();
                break;
            case "java.lang.Double":
                cambiotextoDouble();
                break;
            case "java.lang.Float":
                cambiotextoFloat();
                break;
            case "java.lang.Integer":
                cambiotextoInt();
                break;
            case "java.lang.Long":
                cambiotextoLong();
                break;
            case "java.lang.Math":
                cambiotextoMath();
                break;
            case "java.lang.Number":
                cambiotextoNumber();
                break;
            case "java.lang.Object":
                cambiotextoObject();
                break;
            case "java.lang.Short":
                cambiotextoShort();
                break;
            case "java.lang.String":
                cambiotextoString();
                break;
            case "java.util.ArrayList<E>":
                cambiotextoArrayList();
                break;
            case "java.util.Arrays":
                cambiotextoArrays();
                break;
        }
    }//GEN-LAST:event_jComboBox3ActionPerformed

    /**
     * Metodo void que comprueba el valor seleccionado en el JComboBox3.
     * Dependiendo del valor seleccionado asignara valores a los componentes.
     */
    private void cambiotextoByte() {
        switch (jComboBox3.getSelectedItem().toString()) {
            case "Selecciona un método":
                jTextArea1.setText("");
                jLabel1.setText("");
                break;
            case "-Constructor-":
                jTextArea1.setText("");
                jTextArea1.append("Byte(byte valor)\nConstruye un nuevo objeto Byte que representa el valor dado.");
                jLabel1.setText("");
                break;
            case "byteValue()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna el valor del objeto Byte.");
                jLabel1.setText("byte");
                break;
            case "doubleValue()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna el valor del objeto Byte como un double despues\nde realizar una conversion.");
                jLabel1.setText("double");
                break;
            case "equals(Object obj)":
                jTextArea1.setText("");
                jTextArea1.append("Compara este objeto con el otro objeto especificado.");
                jLabel1.setText("boolean");
                break;
            case "floatValue()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna el valor del objeto Byte como un float despues\nde realizar una conversion.");
                jLabel1.setText("float");
                break;
            case "intValue()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna el valor del objeto Byte como un int despues\nde realizar una conversion.");
                jLabel1.setText("int");
                break;
            case "longValue()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna el valor del objeto Byte como un long despues\nde realizar una conversion.");
                jLabel1.setText("long");
                break;
            case "parseByte(String s)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nAnaliza y convierte el String a un dato de tipo byte.\nEj: Byte.parseByte(String s)");
                jLabel1.setText("static byte");
                break;
            case "shortValue()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna el valor del objeto Byte como un short despues\nde realizar una conversion.");
                jLabel1.setText("short");
                break;
            case "toString()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna un String que representa el valor de este objeto.");
                jLabel1.setText("String");
                break;
            case "toString(byte b)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna un String que representa el valor del byte especificado.\nEj: Byte.toString(byte b)");
                jLabel1.setText("static String");
                break;
            case "valueOf(byte b)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna un objeto Byte que representa el valor dado.\nEj: Byte.valueOf(byte b)");
                jLabel1.setText("static Byte");
                break;
            case "valueOf(String s)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nAnaliza y convierte el String a un objeto Byte.\nEj: Byte.valueOf(String s)");
                jLabel1.setText("static Byte");
                break;
        }
    }

    /**
     * Metodo void que comprueba el valor seleccionado en el JComboBox3.
     * Dependiendo del valor seleccionado asignara valores a los componentes.
     */
    private void cambiotextoChar() {
        switch (jComboBox3.getSelectedItem().toString()) {
            case "Selecciona un método":
                jTextArea1.setText("");
                jLabel1.setText("");
                break;
            case "-Constructor-":
                jTextArea1.setText("");
                jTextArea1.append("Character(char value)\nConstruye un nuevo objeto Character que representa el valor dado.");
                break;
            case "charValue()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna el valor del objeto Char.");
                jLabel1.setText("char");
                break;
            case "equals(Object obj)":
                jTextArea1.setText("");
                jTextArea1.append("Compara este objeto con el otro objeto especificado.");
                jLabel1.setText("boolean");
                break;
            case "isLetter(char ch)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nDetermina si el char especificado es una letra.\nEj: Character.isLetter(char ch)");
                jLabel1.setText("static boolean");
                break;
            case "isLowerCase(char ch)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nDetermina si el char especificado esta en minúscula.\nEj: Character.isLowerCase(char ch)");
                jLabel1.setText("static boolean");
                break;
            case "isUpperCase(char ch)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nDetermina si el char especificado esta en mayúscula.\nEj: Character.isUpperCase(char ch)");
                jLabel1.setText("static boolean");
                break;
            case "isWhitespace(char ch)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nDetermina si el char especificado es un espacio segun Java.\nEj: Character.isWhitespace(char ch)");
                jLabel1.setText("static boolean");
                break;
            case "toLowerCase(char ch)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nConvierte el char especificado a minúscula.\nEj: Character.toLowerCase(char ch)");
                jLabel1.setText("static char");
                break;
            case "toString()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna un String que representa el valor de este objeto.");
                jLabel1.setText("String");
                break;
            case "toString(char c)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna un String que representa el valor del char especificado.\nEj: Character.toString(char c)");
                jLabel1.setText("static String");
                break;
            case "toUpperCase(char ch)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nConvierte el char especificado a mayúscula.\nEj: Character.toUpperCase(char ch)");
                jLabel1.setText("static char");
                break;
            case "valueOf(char c)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nAnaliza y convierte el char a un objeto Character.\nEj: Character.valueOf(char c)");
                jLabel1.setText("static Character");
                break;

        }
    }

    /**
     * Metodo void que comprueba el valor seleccionado en el JComboBox3.
     * Dependiendo del valor seleccionado asignara valores a los componentes.
     */
    private void cambiotextoDouble() {
        switch (jComboBox3.getSelectedItem().toString()) {
            case "Selecciona un método":
                jTextArea1.setText("");
                jLabel1.setText("");
                break;
            case "-Constructor-":
                jTextArea1.setText("");
                jTextArea1.append("Double(double valor)\nConstruye un nuevo objeto Double que representa el valor dado.");
                jLabel1.setText("");
                break;
            case "byteValue()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna el valor del objeto Double como un byte despues\nde realizar una conversion.");
                jLabel1.setText("byte");
                break;
            case "doubleValue()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna el valor del objeto Double.");
                jLabel1.setText("double");
                break;
            case "equals(Object obj)":
                jTextArea1.setText("");
                jTextArea1.append("Compara este objeto con el otro objeto especificado.");
                jLabel1.setText("boolean");
                break;
            case "floatValue()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna el valor del objeto Double como un float despues\nde realizar una conversion.");
                jLabel1.setText("float");
                break;
            case "intValue()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna el valor del objeto Double como un int despues\nde realizar una conversion.");
                jLabel1.setText("int");
                break;
            case "isFinite(double d)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna verdadero si el argumento es un valor finito de punto flotante.\nEj: Double.isFinite(double d)");
                jLabel1.setText("static boolean");
                break;
            case "isInfinite()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna verdadero si el valor de este objeto Double es un valor\ninfinitamente largo en magnitud.");
                jLabel1.setText("boolean");
                break;
            case "isInfinite(double v)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna verdadero si el argumento es un valor\ninfinitamente largo en magnitud.\nEj: Double.isInfinite(double v)");
                jLabel1.setText("static boolean");
                break;
            case "longValue()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna el valor del objeto Double como un long despues\nde realizar una conversion.");
                jLabel1.setText("long");
                break;
            case "parseDouble(String s)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nAnaliza y convierte el String a un dato de tipo double.\nEj: Double.parseDouble(String s)");
                jLabel1.setText("static double");
                break;
            case "shortValue()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna el valor del objeto Double como un short despues\nde realizar una conversion.");
                jLabel1.setText("short");
                break;
            case "toString()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna un String que representa el valor de este objeto.");
                jLabel1.setText("String");
                break;
            case "toString(double d)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna un nuevo String que representa el valor double especificado.\nEj: Double.toString(double d)");
                jLabel1.setText("static String");
                break;
            case "valueOf(double d)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna un objeto Double que representa el valor dado.\nEj: Double.valueOf(double d)");
                jLabel1.setText("static Double");
                break;
            case "valueOf(String s)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nAnaliza y convierte el String a un objeto Double.\nEj: Double.valueOf(String s)");
                jLabel1.setText("static Double");
                break;
        }

    }

    /**
     * Metodo void que comprueba el valor seleccionado en el JComboBox3.
     * Dependiendo del valor seleccionado asignara valores a los componentes.
     */
    private void cambiotextoFloat() {
        switch (jComboBox3.getSelectedItem().toString()) {
            case "Selecciona un método":
                jTextArea1.setText("");
                jLabel1.setText("");
                break;
            case "-Constructor-":
                jTextArea1.setText("");
                jTextArea1.append("Double(double valor)\nConstruye un nuevo objeto Float que representa el argumento\nconvertido a float.\n"
                        + "Float(float valor)\nConstruye un nuevo objeto Float que representa el valor dado.");
                jLabel1.setText("");
                break;
            case "byteValue()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna el valor del objeto Float como un byte despues\nde realizar una conversion.");
                jLabel1.setText("byte");
                break;
            case "doubleValue()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna el valor del objeto Float como un double despues\nde realizar una conversion.");
                jLabel1.setText("double");
                break;
            case "equals(Object obj)":
                jTextArea1.setText("");
                jTextArea1.append("Compara este objeto con el otro objeto especificado.");
                jLabel1.setText("boolean");
                break;
            case "floatValue()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna el valor del objeto Float.");
                jLabel1.setText("float");
                break;
            case "intValue()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna el valor del objeto Float como un int despues\nde realizar una conversion.");
                jLabel1.setText("int");
                break;
            case "isFinite(float f)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna verdadero si el argumento es un valor finito de punto flotante.\nEj: Float.isFinite(float f)");
                jLabel1.setText("static boolean");
                break;
            case "isInfinite()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna verdadero si el valor de este objeto Float es un valor\ninfinitamente largo en magnitud.");
                jLabel1.setText("boolean");
                break;
            case "isInfinite(float f)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna verdadero si el argumento es un valor\ninfinitamente largo en magnitud.\nEj: Float.isInfinite(float v)");
                jLabel1.setText("static boolean");
                break;
            case "longValue()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna el valor del objeto Float como un long despues\nde realizar una conversion.");
                jLabel1.setText("long");
                break;
            case "parseFloat(String s)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nAnaliza y convierte el String a un dato de tipo float.\nEj: Double.parseFloat(String s)");
                jLabel1.setText("static float");
                break;
            case "shortValue()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna el valor del objeto Float como un short despues\nde realizar una conversion.");
                jLabel1.setText("short");
                break;
            case "toString()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna un String que representa el valor de este objeto.");
                jLabel1.setText("String");
                break;
            case "toString(float f)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna un nuevo String que representa el valor float especificado\nEj: Float.toString(float f).");
                jLabel1.setText("static String");
                break;
            case "valueOf(float f)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna un objeto Float que representa el valor dado.\nEj: Float.valueOf(float f)");
                jLabel1.setText("static Float");
                break;
            case "valueOf(String s)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nAnaliza y convierte el String a un objeto Float.\nEj: Float.valueOf(String s)");
                jLabel1.setText("static Float");
                break;
        }

    }

    /**
     * Metodo void que comprueba el valor seleccionado en el JComboBox3.
     * Dependiendo del valor seleccionado asignara valores a los componentes.
     */
    private void cambiotextoInt() {
        switch (jComboBox3.getSelectedItem().toString()) {
            case "Selecciona un método":
                jTextArea1.setText("");
                jLabel1.setText("");
                break;
            case "-Constructor-":
                jTextArea1.setText("");
                jTextArea1.append("Integer(int valor)\nConstruye un nuevo objeto Integer que representa el valor dado.");
                jLabel1.setText("");
                break;
            case "byteValue()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna el valor del objeto Integer como un byte despues\nde realizar una conversion.");
                jLabel1.setText("byte");
                break;
            case "doubleValue()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna el valor del objeto Integer como un double despues\nde realizar una conversion.");
                jLabel1.setText("double");
                break;
            case "equals(Object obj)":
                jTextArea1.setText("");
                jTextArea1.append("Compara este objeto con el otro objeto especificado.");
                jLabel1.setText("boolean");
                break;
            case "floatValue()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna el valor del objeto Integer como un float despues\nde realizar una conversion.");
                jLabel1.setText("float");
                break;
            case "intValue()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna el valor del objeto Integer.");
                jLabel1.setText("int");
                break;
            case "longValue()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna el valor del objeto Integer como un long despues\nde realizar una conversion.");
                jLabel1.setText("long");
                break;
            case "parseInt(String s)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nAnaliza y convierte el String a un dato de tipo int.\nEj: Integer.parseInt(String s)");
                jLabel1.setText("static int");
                break;
            case "parseUnsignedInt(String s)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nAnaliza y convierte el String a un entero decimal sin signo.\nEj: Integer.parseUnsignedInt(int i)");
                jLabel1.setText("static int");
                break;

            case "shortValue()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna el valor del objeto Integer como un short despues\nde realizar una conversion.");
                jLabel1.setText("short");
                break;
            case "toBinaryString(int i)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna un String que representa el valor como un entero sin signo\nde base 2 (Binario).\nEj: Integer.toBinaryString(int i)");
                jLabel1.setText("static String");
                break;
            case "toHexString(int i)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna un String que representa el valor como un entero sin signo\nde base 16 (Hexadecimal).\nEj: Integer.toHexString(int i)");
                jLabel1.setText("static String");
                break;
            case "toOctalString(int i)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna un String que representa el valor como un entero sin signo\nde base 8 (Octal).\nEj: Integer.toOctalString(int i)");
                jLabel1.setText("static String");
                break;
            case "toString()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna un String que representa el valor de este objeto.");
                jLabel1.setText("String");
                break;
            case "toString(int i)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna un String que representa el valor int especificado.\nEj: Integer.toString(int i)");
                jLabel1.setText("static String");
                break;
            case "toUnsignedLong(int x)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nConvierte el argumento a long usando una conversion sin signo.\nEj: Integer.toUnsignedLong(int x)");
                jLabel1.setText("static long");
                break;
            case "toUnsignedString(int i)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna un String que representa el valor como un entero\ndecimal sin signo.\nEj: Integer.toUnsignedString(int i)");
                jLabel1.setText("static String");
                break;
            case "valueOf(int i)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna un objeto Integer que representa el valor dado.\nEj: Integer.valueOf(int i)");
                jLabel1.setText("static Integer");
                break;
            case "valueOf(String s)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nAnaliza y convierte el String a un objeto Integer.\nEj: Integer.valueOf(String s)");
                jLabel1.setText("static Integer");
                break;
        }
    }

    /**
     * Metodo void que comprueba el valor seleccionado en el JComboBox3.
     * Dependiendo del valor seleccionado asignara valores a los componentes.
     */
    private void cambiotextoLong() {
        switch (jComboBox3.getSelectedItem().toString()) {
            case "Selecciona un método":
                jTextArea1.setText("");
                jLabel1.setText("");
                break;
            case "-Constructor-":
                jTextArea1.setText("");
                jTextArea1.append("Long(long valor)\nConstruye un nuevo objeto Long que representa el valor dado.");
                jLabel1.setText("");
                break;
            case "byteValue()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna el valor del objeto Long como un byte despues\nde realizar una conversion.");
                jLabel1.setText("byte");
                break;
            case "doubleValue()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna el valor del objeto Long como un double despues\nde realizar una conversion.");
                jLabel1.setText("double");
                break;
            case "equals(Object obj)":
                jTextArea1.setText("");
                jTextArea1.append("Compara este objeto con el otro objeto especificado.");
                jLabel1.setText("boolean");
                break;
            case "floatValue()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna el valor del objeto Long como un float despues\nde realizar una conversion.");
                jLabel1.setText("float");
                break;
            case "intValue()":
                jTextArea1.setText("Retorna el valor del objeto Long como un int despues\nde realizar una conversion.");
                jTextArea1.append("");
                jLabel1.setText("int");
                break;
            case "longValue()":
                jTextArea1.setText("Retorna el valor del objeto Long.");
                jTextArea1.append("");
                jLabel1.setText("long");
                break;
            case "parseLong(String s)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nAnaliza y convierte el String a un dato de tipo long.\nEj: Long.parseLong(String s)");
                jLabel1.setText("static long");
                break;
            case "parseUnsignedLong(String s)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nAnaliza y convierte el String a un entero decimal sin signo.\nEj: Long.parseUnsignedLong(String s))");
                jLabel1.setText("static long");
                break;

            case "shortValue()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna el valor del objeto Long como un short despues\nde realizar una conversion.");
                jLabel1.setText("short");
                break;
            case "toBinaryString(long i)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna un String que representa el valor como un entero sin signo\nde base 2 (Binario).\nEj: Long.toBinaryString(long i)");
                jLabel1.setText("static String");
                break;
            case "toHexString(long i)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna un String que representa el valor como un entero sin signo\nde base 16 (Hexadecimal).\nEj: Long.toHexString(long i)");
                jLabel1.setText("static String");
                break;
            case "toOctalString(long i)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna un String que representa el valor como un entero sin signo\nde base 8 (Octal).\nEj: Long.toOctalString(long i)");
                jLabel1.setText("static String");
                break;
            case "toString()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna un String que representa el valor de este objeto.");
                jLabel1.setText("String");
                break;
            case "toString(long i)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna un String que representa el valor long especificado.\nEj: Long.toString(long i)");
                jLabel1.setText("static String");
                break;
            case "toUnsignedString(long i)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna un String que representa el valor como un entero\ndecimal sin signo.\nEj: Long.toUnsignedString(long i)");
                jLabel1.setText("static String");
                break;
            case "valueOf(long i)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna un objeto Long que representa el valor dado.\nEj: Long.valueOf(long i)");
                jLabel1.setText("static Long");
                break;
            case "valueOf(String s)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nAnaliza y convierte el String a un objeto Long.\nEj: Long.valueOf(String s)");
                jLabel1.setText("static Long");
                break;
        }
    }

    /**
     * Metodo void que comprueba el valor seleccionado en el JComboBox3.
     * Dependiendo del valor seleccionado asignara valores a los componentes.
     */
    private void cambiotextoMath() {
        switch (jComboBox3.getSelectedItem().toString()) {
            case "Selecciona un método":
                jTextArea1.setText("");
                jLabel1.setText("");
                break;
            case "-Constantes-":
                jTextArea1.setText("");
                jTextArea1.append("Metodos Estaticos\nE\nValor double que es el mas cercano a e que cualquier otro.\nEj: Math.E()\n");
                jTextArea1.append("PI\nValor double que es el mas cercano a pi que cualquier otro.\nEj: Math.PI()");
                jLabel1.setText("static double");
                break;
            case "abs(double a)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna el valor absoluto de un valor double.\nEj: Math.abs(double a)");
                jLabel1.setText("static double");
                break;
            case "abs(float a)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna el valor absoluto de un valor float.\nEj: Math.abs(float a)");
                jLabel1.setText("static float");
                break;
            case "abs(int a)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna el valor absoluto de un valor int.\nEj: Math.abs(int a)");
                jLabel1.setText("static int");
                break;
            case "abs(long a)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna el valor absoluto de un valor long.\nEj: Math.abs(long a)");
                jLabel1.setText("static long");
                break;
            case "acos(double a)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna el arcocoseno del valor. Rango(0.0,pi)\nEj: Math.acos(double a).");
                jLabel1.setText("static double");
                break;
            case "asin(double a)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna el arcoseno del valor. Rango(-pi/2,pi/2)\nEj: Math.asin(double a).");
                jLabel1.setText("static double");
                break;
            case "atan(double a)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna el arcotangente del valor. Rango(-pi/2,pi/2)\nEj: Math.atan(double a).");
                jLabel1.setText("static double");
                break;
            case "atan2(double y,double x)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna el angulo theta desde una conversion de coordenadas\nrectangulares (x,y) a coordenadas polares (r,theta).\nEj: Math.atan2(double y,double x).");
                jLabel1.setText("static double");
                break;
            case "cbrt(double a)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna la raiz cubica de un valor double.\nEj: Math.cbrt(double a).");
                jLabel1.setText("static double");
                break;
            case "ceil(double a)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna el mas pequeño(cercano al infinito negativo) valor double\nque es mayor o igual que el argumento y que es igual a un entero.\nEn pocas palabra redondea hacia arriba.\nEj: Math.ceil(double a)");
                jLabel1.setText("static double");
                break;
            case "copySign(double magnitude,double sign)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna el primer argumento con el signo del segundo argumento.\nEj: Math.copySign(double magnitude,double sign)");
                jLabel1.setText("static double");
                break;
            case "copySign(float magnitude,float sign)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna el primer argumento con el signo del segundo argumento.\nEj: Math.copySign(float magnitude,float sign)");
                jLabel1.setText("static float");
                break;
            case "cos(double a)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna el coseno trigonometrico de un angulo.\nEj: Math.cos(double a)");
                jLabel1.setText("static double");
                break;
            case "cosh(double x)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna el coseno hiperbolico de un angulo.\nEj: Math.cosh(double x)");
                jLabel1.setText("static double");
                break;
            case "exp(double a)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\n.Retorna el numero de Euler (e) elevado al argumento.\nEj: Math.exp(double a)");
                jLabel1.setText("static double");
                break;
            case "expm1(double x)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\n.Retorna (e^2)-1.\nEj: Math.expm1(double x)");
                jLabel1.setText("static double");
                break;
            case "floor(double a)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna el mas grande(cercano al infinito positivo) valor double\nque es menor o igual que el argumento y que es igual a un entero.\nEn pocas palabra redondea hacia abajo.\nEj: Math.floor(double a)");
                jLabel1.setText("static double");
                break;
            case "hypot(double x,double y)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna sqrt(x^2 + y^2) sin desbordamiento o subflujo intermedio.\nEj: Math.hypot(double x,double y)");
                jLabel1.setText("static double");
                break;
            case "log(double a)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna el logaritmo natural (base e) del argumento double.\nEj: Math.log(double a)");
                jLabel1.setText("static double");
                break;
            case "log10(double a)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna el logaritmo base 10 del argumento double.\nEj: Math.log10(double a)");
                jLabel1.setText("static double");
                break;
            case "log1p(double x)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna el logaritmo natural entre la suma del argumento y 1 (x+1).\nEj: Math.log1p(double x)");
                jLabel1.setText("static double");
                break;
            case "max(double a,double b)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna el mayor entre 2 valores double.\nEj: Math.max(double a,double b)");
                jLabel1.setText("static double");
                break;
            case "max(float a,float b)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna el mayor entre 2 valores float.\nEj: Math.max(float a,float b)");
                jLabel1.setText("static float");
                break;
            case "max(int a,int b)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna el mayor entre 2 valores int.\nEj: Math.max(int a,int b)");
                jLabel1.setText("static int");
                break;
            case "max(long a,long b)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna el mayor entre 2 valores long.\nEj: Math.max(long a,long b)");
                jLabel1.setText("static long");
                break;
            case "min(double a,double b)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna el menor entre 2 valores double.\nEj: Math.min(double a,double b)");
                jLabel1.setText("static double");
                break;
            case "min(float a,float b)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna el menor entre 2 valores float.\nEj: Math.min(float a,float b)");
                jLabel1.setText("static float");
                break;
            case "min(int a,int b)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna el menor entre 2 valores int.\nEj: Math.min(int a,int b)");
                jLabel1.setText("static int");
                break;
            case "min(long a,long b)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna el menor entre 2 valores long.\nEj: Math.min(long a,long b)");
                jLabel1.setText("static long");
                break;
            case "pow(double a,double b)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna el valor del primer argumento elevado al segundo.\nEj: Math.pow(double a,double b)");
                jLabel1.setText("static double");
                break;
            case "random()":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna un valor double,con signo positivo,mayor o igual que 0.0\ny menor que 1.0.\nEj: Math.random()");
                jLabel1.setText("static double");
                break;
            case "rint(double a)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna el valor double mas cercano en valor al argumento que es\nigual a un entero.\nEj: Math.rint(double a)");
                jLabel1.setText("static double");
                break;
            case "round(double a)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna el long mas cercano al argumento redondeado\nal infinito positivo.\nEj: Math.round(double a)");
                jLabel1.setText("static long");
                break;
            case "round(float a)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna el int mas cercano al argumento redondeado\nal infinito positivo.\nEj: Math.round(float a)");
                jLabel1.setText("static long");
                break;
            case "sin(double a)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna el seno trigonometrico de un angulo.\nEj: Math.sin(double a)");
                jLabel1.setText("static double");
                break;
            case "sinh(double a)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna el seno hiperbolico de un angulo.\nEj: Math.sinh(double a)");
                jLabel1.setText("static double");
                break;
            case "sqrt(double a)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna la raiz cuadrada de un valor double.\nEj: Math.sqrt(double a).");
                jLabel1.setText("static double");
                break;
            case "tan(double a)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna la tangente trigonometrica de un angulo.\nEj: Math.tan(double a)");
                jLabel1.setText("static double");
                break;
            case "tanh(double a)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna tangente hiperbolica de un angulo.\nEj: Math.tanh(double a)");
                jLabel1.setText("static double");
                break;
            case "toDegrees(double angrad)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nConvierte el angulo expresado en radianes a su angulo aproximado\nexpresado en grados.\nEj: Math.toDegrees(double angrad)");
                jLabel1.setText("static double");
                break;
            case "toRadians(double angdeg)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nConvierte el angulo expresado en grado a su angulo aproximado\nexpresado en radianes.\nEj: Math.toRadians(double angdeg)");
                jLabel1.setText("static double");
                break;
        }
    }

    /**
     * Metodo void que comprueba el valor seleccionado en el JComboBox3.
     * Dependiendo del valor seleccionado asignara valores a los componentes.
     */
    private void cambiotextoObject() {
        switch (jComboBox3.getSelectedItem().toString()) {
            case "Selecciona un método":
                jTextArea1.setText("");
                jLabel1.setText("");
                break;
            case "-Constructor-":
                jTextArea1.setText("");
                jTextArea1.append("Object()");
                jLabel1.setText("");
                break;
            case "clone()":
                jTextArea1.setText("");
                jTextArea1.append("Crea y retorna una copia del objeto.");
                jLabel1.setText("protected Object");
                break;
            case "equals(Object obj)":
                jTextArea1.setText("");
                jTextArea1.append("Indica si otro objeto es \"igual a\" este.");
                jLabel1.setText("boolean");
                break;
            case "toString()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna una representacion String del objeto.");
                jLabel1.setText("String");
                break;

        }
    }

    /**
     * Metodo void que comprueba el valor seleccionado en el JComboBox3.
     * Dependiendo del valor seleccionado asignara valores a los componentes.
     */
    private void cambiotextoNumber() {
        switch (jComboBox3.getSelectedItem().toString()) {
            case "Selecciona un método":
                jTextArea1.setText("");
                jLabel1.setText("");
                break;
            case "-Constructor-":
                jTextArea1.setText("");
                jTextArea1.append("Number()");
                jLabel1.setText("");
                break;
            case "byteValue()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna el valor del numero especificado como un byte\nlo que puede implicar redondeo o truncamiento.");
                jLabel1.setText("byte");
                break;
            case "doubleValue()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna el valor del numero especificado como un double\nlo que puede implicar redondeo.");
                jLabel1.setText("abstract double");
                break;
            case "floatValue()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna el valor del numero especificado como un float\nlo que puede implicar redondeo.");
                jLabel1.setText("abstract float");
                break;
            case "intValue()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna el valor del numero especificado como un int\nlo que puede implicar redondeo o truncamiento.");
                jLabel1.setText("abstract int");
                break;
            case "shortValue()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna el valor del numero especificado como un short\nlo que puede implicar redondeo o truncamiento.");
                jLabel1.setText("short");
                break;
        }
    }

    /**
     * Metodo void que comprueba el valor seleccionado en el JComboBox3.
     * Dependiendo del valor seleccionado asignara valores a los componentes.
     */
    private void cambiotextoShort() {
        switch (jComboBox3.getSelectedItem().toString()) {
            case "Selecciona un método":
                jTextArea1.setText("");
                jLabel1.setText("");
                break;
            case "-Constructor-":
                jTextArea1.setText("");
                jTextArea1.append("Short(short valor)\nConstruye un nuevo objeto short que representa el valor dado.");
                jLabel1.setText("");
                break;
            case "byteValue()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna el valor del objeto Short como un byte despues\nde realizar una conversion.");
                jLabel1.setText("byte");
                break;
            case "doubleValue()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna el valor del objeto Short como un double despues\nde realizar una conversion.");
                jLabel1.setText("double");
                break;
            case "equals(Object obj)":
                jTextArea1.setText("");
                jTextArea1.append("Compara este objeto con el otro objeto especificado.");
                jLabel1.setText("boolean");
                break;
            case "floatValue()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna el valor del objeto Short como un float despues\nde realizar una conversion.");
                jLabel1.setText("float");
                break;
            case "intValue()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna el valor del objeto Short como un int despues\nde realizar una conversion.");
                jLabel1.setText("int");
                break;
            case "longValue()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna el valor del objeto Short como un long despues\nde realizar una conversion.");
                jLabel1.setText("long");
                break;
            case "parseShort(String s)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nAnaliza y convierte el String a un dato de tipo short.\nEj: Short.parseShort(String s)");
                jLabel1.setText("static short");
                break;
            case "shortValue()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna el valor del objeto Short.");
                jLabel1.setText("short");
                break;
            case "toString()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna un String que representa el valor de este objeto.");
                jLabel1.setText("String");
                break;
            case "toString(short s)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna un String que representa el valor int especificado.\nEj: Short.toString(short s)");
                jLabel1.setText("static String");
                break;
            case "toUnsignedInt(short x)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nConvierte el argumento a int usando una conversion sin signo.\nEj: Short.toUnsignedLong(short x)");
                jLabel1.setText("static int");
                break;
            case "toUnsignedLong(short x)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nConvierte el argumento a long usando una conversion sin signo.\nEj: Short.toUnsignedLong(short x)");
                jLabel1.setText("static long");
                break;
            case "valueOf(short s)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna un objeto Short que representa el valor dado.\nEj: Short.valueOf(short s)");
                jLabel1.setText("static Short");
                break;
            case "valueOf(String s)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nAnaliza y convierte el String a un objeto Short.\nEj: Short.valueOf(String s)");
                jLabel1.setText("static Short");
                break;
        }
    }

    /**
     * Metodo void que comprueba el valor seleccionado en el JComboBox3.
     * Dependiendo del valor seleccionado asignara valores a los componentes.
     */
    private void cambiotextoString() {
        switch (jComboBox3.getSelectedItem().toString()) {
            case "Selecciona un método":
                jTextArea1.setText("");
                jLabel1.setText("");
                break;
            case "-Constructor-":
                jTextArea1.setText("");
                jTextArea1.append("String()\nCrea un nuevo String vacio.\nString(char[] value)\nCrea un nuevo String que representa la secuencia "
                        + "de caracteres\ncontenida en el arreglo.\nString(String original)\nCrea una nueva copia del argumento.");
                jLabel1.setText("");
                break;
            case "charAt(int index)":
                jTextArea1.setText("");
                jTextArea1.append("Retorna el valor char del indice especificado.");
                jLabel1.setText("char");
                break;
            case "compareTo(String anotherString)":
                jTextArea1.setText("");
                jTextArea1.append("Compara 2 Strings lexicograficamente.\nDevuelve 0 si son iguales,menor a 0 si este String es menor al otro,\nmayor a 0 si es mayor al otro");
                jLabel1.setText("int");
                break;
            case "compareToIgnoreCase(String str)":
                jTextArea1.setText("");
                jTextArea1.append("Compara 2 Strings lexicograficamente ignorando si es mayuscula\no minuscula.");
                jLabel1.setText("int");
                break;
            case "concat(String str)":
                jTextArea1.setText("");
                jTextArea1.append("Concatena el argumento al final de este String.");
                jLabel1.setText("String");
                break;
            case "contains(CharSecuence s)":
                jTextArea1.setText("");
                jTextArea1.append("Retorna true si y solo si el String contiene la secuencia\nespecificada de caracteres.");
                jLabel1.setText("boolean");
                break;
            case "contentEquals(CharSequence cs)":
                jTextArea1.setText("");
                jTextArea1.append("Compara este String con el CharSequencebespecificado.");
                jLabel1.setText("boolean");
                break;
            case "endsWith(String suffix)":
                jTextArea1.setText("");
                jTextArea1.append("Prueba si el String termina con el sufijo especificado.");
                jLabel1.setText("boolean");
                break;
            case "equals(Object anObject)":
                jTextArea1.setText("");
                jTextArea1.append("Compara este String con el objeto especificado.");
                jLabel1.setText("boolean");
                break;
            case "equalsIgnoreCase(String anotherString)":
                jTextArea1.setText("");
                jTextArea1.append("Compara este String con otro String ignorando si es mayúscula\no minúscula.");
                jLabel1.setText("boolean");
                break;
            case "getChars(int srcBegin,int srcEnd,char[] dst,int dstBegin)":
                jTextArea1.setText("");
                jTextArea1.append("Copia los caracteres de este String al arreglo destino.\nParametros:"
                        + "\nsrcBegin: Indice del primer caracter en el String a copiar.\nsrcEnd: Indice despues del ultimo caracter en el String a copiar.\n"
                        + "dst: Arreglo de char destino.\ndstBegin: Indice de comienzo en el arreglo destino");
                jLabel1.setText("void");
                break;
            case "indexOf(String str)":
                jTextArea1.setText("");
                jTextArea1.append("Retorna el indice donde esta la primera coincidencia con\nel substring especificado.\nRetorna -1 si no hay coincidencia.");
                jLabel1.setText("int");
                break;
            case "indexOf(String str,int fromIndex)":
                jTextArea1.setText("");
                jTextArea1.append("Retorna el indice donde esta la primera coincidencia con\nel substring especificado, empezando en el indice dado.\nRetorna -1 si no hay coincidencia.");
                jLabel1.setText("int");
                break;
            case "isEmpty()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna true si y solo si length() es 0.");
                jLabel1.setText("boolean");
                break;
            case "lastIndexOf(String str)":
                jTextArea1.setText("");
                jTextArea1.append("Retorna el indice donde esta la ultima coincidencia con\nel substring especificado.\nRetorna -1 si no hay coincidencia.");
                jLabel1.setText("int");
                break;
            case "lastIndexOf(String str,int fromIndex)":
                jTextArea1.setText("");
                jTextArea1.append("Retorna el indice donde esta la ultima coincidencia con\nel substring especificado, empezando en el indice dado.\nRetorna -1 si no hay coincidencia.");
                jLabel1.setText("int");
                break;
            case "length()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna el tamaño del String.");
                jLabel1.setText("int");
                break;
            case "regionMatches(boolean ignoreCase,int toffset,String other,int ooffset,int len)":
                jTextArea1.setText("");
                jTextArea1.append("Prueba si las regiones de 2 String son iguales.\nParametros:\nignoreCase: Si es true ignora las mayúsculas y minúsculas.\n"
                        + "toffset: El indice de comienzo de subregion en este String.\nother: El otro argumento String.\nooffset: El indice de comienzo de subregion en String argumento.\nlen: Numero de caracteres a comparar.");
                jLabel1.setText("boolean");
                break;
            case "regionMatches(int toffset,String other,int ooffset,int len)":
                jTextArea1.setText("");
                jTextArea1.append("Prueba si las regiones de 2 String son iguales.\nParametros:\ntoffset: El indice de comienzo de subregion en este String."
                        + "\nother: El otro argumento String.\nooffset: El indice de comienzo de subregion en String argumento.\nlen: Numero de caracteres a comparar.");
                jLabel1.setText("boolean");
                break;
            case "replace(char oldChar,char newChar)":
                jTextArea1.setText("");
                jTextArea1.append("Retorna un String resultante de reemplazar todas las coincidencias\nde oldChar en el String con newChar.");
                jLabel1.setText("String");
                break;
            case "replace(CharSequence target,String replacement":
                jTextArea1.setText("");
                jTextArea1.append("Reemplaza cada substring de este String que coincide con la secuencia\nobjetivo, con la secuencia de reemplazo.");
                jLabel1.setText("String");
                break;
            case "replaceAll(String regex,String replacement)":
                jTextArea1.setText("");
                jTextArea1.append("Reemplaza cada substring en este String que coincide con la\nExpresion Regular dada, por el String de reemplazo.");
                jLabel1.setText("String");
                break;
            case "replaceFirst(String regex,String replacement)":
                jTextArea1.setText("");
                jTextArea1.append("Reemplaza el primer substring en este String que coincide con la\nExpresion Regular dada, por el String de reemplazo.");
                jLabel1.setText("String");
                break;
            case "startsWith(String prefix)":
                jTextArea1.setText("");
                jTextArea1.append("Prueba si el String comienza con el prefijo dado.");
                jLabel1.setText("boolean");
                break;
            case "startsWith(String prefix,int toffset)":
                jTextArea1.setText("");
                jTextArea1.append("Prueba si el subtring de este String que comienza en el indice\nespecificado comienza con el prefijo dado.");
                jLabel1.setText("boolean");
                break;
            case "substring(int beginIndex)":
                jTextArea1.setText("");
                jTextArea1.append("Retorna un String que es substring de este String.");
                jLabel1.setText("String");
                break;
            case "substring(int beginIndex,int endIndex)":
                jTextArea1.setText("");
                jTextArea1.append("Retorna un String que es substring de este String.");
                jLabel1.setText("String");
                break;
            case "toCharArray()":
                jTextArea1.setText("");
                jTextArea1.append("Convierte este String en un arreglo de char.");
                jLabel1.setText("char[]");
                break;
            case "toLowerCase()":
                jTextArea1.setText("");
                jTextArea1.append("Convierte todos los caracteres del String en minúscula.");
                jLabel1.setText("String");
                break;
            case "toString()":
                jTextArea1.setText("");
                jTextArea1.append("Este objeto (¡el cual ya es un String!) es retornado.");
                jLabel1.setText("String");
                break;
            case "toUpperCase()":
                jTextArea1.setText("");
                jTextArea1.append(".Convierte todos los caracteres del String en mayúscula");
                jLabel1.setText("String");
                break;
            case "trim()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna el valor de este String sin ningun espacio al comienzo o final.");
                jLabel1.setText("String");
                break;
            case "valueOf(boolean b)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna la representacion en String del argumento booleano.\nEj: String.valueOf(boolean b)");
                jLabel1.setText("static String");
                break;
            case "valueOf(char c)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna la representacion en String del argumento char.\nEj: String.valueOf(char c)");
                jLabel1.setText("static String");
                break;
            case "valueOf(char[] data)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna la representacion en String del arreglo de char argumento.\nEj: String.valueOf(char[] data)");
                jLabel1.setText("static String");
                break;
            case "valueOf(char[] data,int offset,int count)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna la representacion en String del subarreglo de char argumento.\nEj: String.valueOf(boolean b)\nParametros:\nchar[] data: El arreglo de char.\noffset: Indice inicial del subarreglo.\ncount: Tamaño del subarreglo.");
                jLabel1.setText("static String");
                break;
            case "valueOf(double d)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna la representacion en String del argumento double.\nEj: String.valueOf(double d)");
                jLabel1.setText("static String");
                break;
            case "valueOf(float f)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna la representacion en String del argumento float.\nEj: String.valueOf(float f)");
                jLabel1.setText("static String");
                break;
            case "valueOf(int i)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna la representacion en String del argumento int.\nEj: String.valueOf(int i)");
                jLabel1.setText("static String");
                break;
            case "valueOf(long l)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna la representacion en String del argumento long.\nEj: String.valueOf(long l)");
                jLabel1.setText("static String");
                break;
            case "valueOf(Object obj)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna la representacion en String del argumento Object.\nEj: String.valueOf(Object obj)");
                jLabel1.setText("static String");
                break;
        }
    }

    /**
     * Metodo void que comprueba el valor seleccionado en el JComboBox3.
     * Dependiendo del valor seleccionado asignara valores a los componentes.
     */
    private void cambiotextoArrayList() {
        switch (jComboBox3.getSelectedItem().toString()) {
            case "Selecciona un método":
                jTextArea1.setText("");
                jLabel1.setText("");
                break;
            case "-Constructor-":
                jTextArea1.setText("");
                jTextArea1.append("ArrayList()<E>\nConstruye una lista vacia con una capacidad inicial de 10.\n"
                        + "ArrayList(Collection<? extends E> c)<E>\nConstruye una lista que contiene los elementos de la Coleccion dada.\n"
                        + "ArrayList(int initialCapacity)<E>\nConstruye una lista vacia con la capacidad inicial dada.");
                jLabel1.setText("Parametros de Tipo E (Generico)");
                break;
            case "add(E e)":
                jTextArea1.setText("");
                jTextArea1.append("Añade el elemento al final de la lista.");
                jLabel1.setText("boolean");
                break;
            case "add(int index, E element)":
                jTextArea1.setText("");
                jTextArea1.append("Inserta el elemento en la posicion especificada en la lista.");
                jLabel1.setText("void");
                break;
            case "addAll(Collection<? extends E> c)":
                jTextArea1.setText("");
                jTextArea1.append("Añade todos los elementos de la Coleccion al final de la lista.");
                jLabel1.setText("boolean");
                break;
            case "addAll(int index,Collection<? extends E> c)":
                jTextArea1.setText("");
                jTextArea1.append("Inserta todos los elementos de la Coleccion en la posicion\nespecificada en la lista.");
                jLabel1.setText("");
                break;
            case "clear()":
                jTextArea1.setText("");
                jTextArea1.append("Remueve todos los elementos de la lista.");
                jLabel1.setText("void");
                break;
            case "clone()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna una copia superficial de este ArrayList.");
                jLabel1.setText("Object");
                break;
            case "contains(Object o)":
                jTextArea1.setText("");
                jTextArea1.append("Retorna true si y solo si la lista contiene el elemento especificado.");
                jLabel1.setText("boolean");
                break;
            case "ensureCapacity(int minCapacity)":
                jTextArea1.setText("");
                jTextArea1.append("Incrementa la capacidad de este ArrayList, si es necesario,\npara asegurar que al menos puede contener la "
                        + "cantidad de elementos\ndel argumento.");
                jLabel1.setText("void");
                break;
            case "get(int index)":
                jTextArea1.setText("");
                jTextArea1.append("Retorna el elemento en la posicion especificada de la lista.");
                jLabel1.setText("E");
                break;
            case "indexOf(Object o)":
                jTextArea1.setText("");
                jTextArea1.append("Retorna el indice de la primera coincidencia del elemento en la lista,\no -1 si la lista no contiene el elemento.");
                jLabel1.setText("int");
                break;
            case "isEmpty()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna true si la lista no contiene elementos.");
                jLabel1.setText("boolean");
                break;
            case "lastIndexOf(Object o)":
                jTextArea1.setText("");
                jTextArea1.append("Retorna el indice de la ultima coincidencia del elemento en la lista,\no -1 si la lista no contiene el elemento.");
                jLabel1.setText("int");
                break;
            case "remove(int index)":
                jTextArea1.setText("");
                jTextArea1.append("Remueve el elemento de la lista en la posicion especificada.");
                jLabel1.setText("E");
                break;
            case "remove(Object o)":
                jTextArea1.setText("");
                jTextArea1.append("Remueve la primera coincidencia en la lista del elemento especificado si existe.");
                jLabel1.setText("boolean");
                break;
            case "removeAll(Collection<?> c)":
                jTextArea1.setText("");
                jTextArea1.append("Remueve de la lista todos los elementos contenidos en la Coleccion dada.");
                jLabel1.setText("boolean");
                break;
            case "removeRange(int fromIndex,int toIndex)":
                jTextArea1.setText("");
                jTextArea1.append("Remueve de la lista todos los elementos cuyo indice esta entre el rango\nfromIndex inclusivo, toIndex exclusivo.");
                jLabel1.setText("protected void");
                break;
            case "retainAll(Collection<?> c)":
                jTextArea1.setText("");
                jTextArea1.append("Retiene unicamente los elementos en la lista que estan presentes\nen la Coleccion.");
                jLabel1.setText("boolean");
                break;
            case "set(int index E element)":
                jTextArea1.setText("");
                jTextArea1.append("Reemplaza el elemento en la posicion especificada\npor el elemento dado.");
                jLabel1.setText("E");
                break;
            case "size()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna el numero de elementos en esta lista.");
                jLabel1.setText("int");
                break;
            case "toArray()":
                jTextArea1.setText("");
                jTextArea1.append("Retorna un arreglo conteniendo todos los elementos en esta lista\nen la secuencia correcta (Del primer al ultimo elemento).");
                jLabel1.setText("Object[]");
                break;
            case "toArray(T[] a)":
                jTextArea1.setText("");
                jTextArea1.append("Retorna un arreglo conteniendo todos los elementos en esta lista\nen la secuencia correcta (Del primer al ultimo elemento).\nEl tipo del arreglo retornado es el del arreglo especificado.");
                jLabel1.setText("<T> T[]");
                break;
            case "trimToSize()":
                jTextArea1.setText("");
                jTextArea1.append("Recorta la capacidad de este ArrayList para ser del tamaño actual de la lista.");
                jLabel1.setText("void");
                break;
        }
    }

    /**
     * Metodo void que comprueba el valor seleccionado en el JComboBox3.
     * Dependiendo del valor seleccionado asignara valores a los componentes.
     */
    private void cambiotextoArrays() {
        switch (jComboBox3.getSelectedItem().toString()) {
            case "Selecciona un método":
                jTextArea1.setText("");
                jLabel1.setText("");
                break;
            case "asList(T... a)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna una de tamaño fijo respaldada por el arreglo dado.\nEj: Arrays.asList(T... a)");
                jLabel1.setText("static <T> List<T>");
                break;
            case "bynarySearch(byte[] a,byte key)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nBusca en el arreglo de por el valor espeficado usando el algoritmo\nde busqueda binaria, el arreglo debe estar ordenado antes\n"
                        + "de realizar la llamada a este metodo, de lo contrario los resultados son\nindefinidos, si contiene varios elementos del mismo valor\n"
                        + "no hay garantia de cual sera encontrado.\n"
                        + "Retorna el índice de la clave de búsqueda, si está contenido en el arreglo,\nde lo contrario, (-(punto de inserción)-1). El punto de inserción se define\n"
                        + "como el punto en el que la clave se insertaría en el arreglo:\nel índice del primer elemento mayor que la clave, o una longitud si todos\n"
                        + "los elementos del arreglo son menores que la clave especificada.\nTenga en cuenta que esto garantiza que el valor de retorno.\n"
                        + "será >= 0 si y solo si se encuentra la clave.\nEj: Arrays.bynarySearch(byte[] a,byte key)");
                jLabel1.setText("static int");
                break;
            case "bynarySearch(byte[] a,int fromIndex,int toIndex,byte key)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nBusca en el arreglo de por el valor espeficado usando el algoritmo\nde busqueda binaria, el rango debe estar ordenado antes\n"
                        + "de realizar la llamada a este metodo, de lo contrario los resultados son\nindefinidos, si contiene varios elementos del mismo valor\n"
                        + "no hay garantia de cual sera encontrado.\n"
                        + "Retorna el índice de la clave de búsqueda, si está contenido en el arreglo,\nde lo contrario, (-(punto de inserción)-1). El punto de inserción se define\n"
                        + "como el punto en el que la clave se insertaría en el arreglo:\nel índice del primer elemento mayor que la clave, o una longitud si todos\n"
                        + "los elementos del arreglo son menores que la clave especificada.\nTenga en cuenta que esto garantiza que el valor de retorno.\n"
                        + "será >= 0 si y solo si se encuentra la clave.\nEj: Arrays.bynarySearch(byte[] a,int fromIndex,int toIndex,byte key)");
                jLabel1.setText("static int");
                break;
            case "bynarySearch(char[] a,char key)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nBusca en el arreglo de por el valor espeficado usando el algoritmo\nde busqueda binaria, el arreglo debe estar ordenado antes\n"
                        + "de realizar la llamada a este metodo, de lo contrario los resultados son\nindefinidos, si contiene varios elementos del mismo valor\n"
                        + "no hay garantia de cual sera encontrado.\n"
                        + "Retorna el índice de la clave de búsqueda, si está contenido en el arreglo,\nde lo contrario, (-(punto de inserción)-1). El punto de inserción se define\n"
                        + "como el punto en el que la clave se insertaría en el arreglo:\nel índice del primer elemento mayor que la clave, o una longitud si todos\n"
                        + "los elementos del arreglo son menores que la clave especificada.\nTenga en cuenta que esto garantiza que el valor de retorno.\n"
                        + "será >= 0 si y solo si se encuentra la clave.\nEj: Arrays.bynarySearch(char[] a,char key)");
                jLabel1.setText("static int");
                break;
            case "bynarySearch(char[] a,int fromIndex,int toIndex,char key)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nBusca en el arreglo de por el valor espeficado usando el algoritmo\nde busqueda binaria, el rango debe estar ordenado antes\n"
                        + "de realizar la llamada a este metodo, de lo contrario los resultados son\nindefinidos, si contiene varios elementos del mismo valor\n"
                        + "no hay garantia de cual sera encontrado.\n"
                        + "Retorna el índice de la clave de búsqueda, si está contenido en el arreglo,\nde lo contrario, (-(punto de inserción)-1). El punto de inserción se define\n"
                        + "como el punto en el que la clave se insertaría en el arreglo:\nel índice del primer elemento mayor que la clave, o una longitud si todos\n"
                        + "los elementos del arreglo son menores que la clave especificada.\nTenga en cuenta que esto garantiza que el valor de retorno.\n"
                        + "será >= 0 si y solo si se encuentra la clave.\nEj: Arrays.bynarySearch(char[] a,int fromIndex,int toIndex,char key)");
                jLabel1.setText("static int");
                break;
            case "bynarySearch(double[] a, double key)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nBusca en el arreglo de por el valor espeficado usando el algoritmo\nde busqueda binaria, el arreglo debe estar ordenado antes\n"
                        + "de realizar la llamada a este metodo, de lo contrario los resultados son\nindefinidos, si contiene varios elementos del mismo valor\n"
                        + "no hay garantia de cual sera encontrado.\n"
                        + "Retorna el índice de la clave de búsqueda, si está contenido en el arreglo,\nde lo contrario, (-(punto de inserción)-1). El punto de inserción se define\n"
                        + "como el punto en el que la clave se insertaría en el arreglo:\nel índice del primer elemento mayor que la clave, o una longitud si todos\n"
                        + "los elementos del arreglo son menores que la clave especificada.\nTenga en cuenta que esto garantiza que el valor de retorno.\n"
                        + "será >= 0 si y solo si se encuentra la clave.\nEj: Arrays.bynarySearch(double[] a, double key)");
                jLabel1.setText("static int");
                break;
            case "bynarySearch(double[] a,int fromIndex,int toIndex,double key)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nBusca en el arreglo de por el valor espeficado usando el algoritmo\nde busqueda binaria, el rango debe estar ordenado antes\n"
                        + "de realizar la llamada a este metodo, de lo contrario los resultados son\nindefinidos, si contiene varios elementos del mismo valor\n"
                        + "no hay garantia de cual sera encontrado.\n"
                        + "Retorna el índice de la clave de búsqueda, si está contenido en el arreglo,\nde lo contrario, (-(punto de inserción)-1). El punto de inserción se define\n"
                        + "como el punto en el que la clave se insertaría en el arreglo:\nel índice del primer elemento mayor que la clave, o una longitud si todos\n"
                        + "los elementos del arreglo son menores que la clave especificada.\nTenga en cuenta que esto garantiza que el valor de retorno.\n"
                        + "será >= 0 si y solo si se encuentra la clave.\nEj: Arrays.bynarySearch(double[] a,int fromIndex,int toIndex,double key)");
                jLabel1.setText("static int");
                break;
            case "bynarySearch(float[] a,float key)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nBusca en el arreglo de por el valor espeficado usando el algoritmo\nde busqueda binaria, el arreglo debe estar ordenado antes\n"
                        + "de realizar la llamada a este metodo, de lo contrario los resultados son\nindefinidos, si contiene varios elementos del mismo valor\n"
                        + "no hay garantia de cual sera encontrado.\n"
                        + "Retorna el índice de la clave de búsqueda, si está contenido en el arreglo,\nde lo contrario, (-(punto de inserción)-1). El punto de inserción se define\n"
                        + "como el punto en el que la clave se insertaría en el arreglo:\nel índice del primer elemento mayor que la clave, o una longitud si todos\n"
                        + "los elementos del arreglo son menores que la clave especificada.\nTenga en cuenta que esto garantiza que el valor de retorno.\n"
                        + "será >= 0 si y solo si se encuentra la clave.\nEj: Arrays.bynarySearch(float[] a,float key)");
                jLabel1.setText("static int");
                break;
            case "bynarySearch(float[] a,int fromIndex,int toIndex,float key)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nBusca en el arreglo de por el valor espeficado usando el algoritmo\nde busqueda binaria, el rango debe estar ordenado antes\n"
                        + "de realizar la llamada a este metodo, de lo contrario los resultados son\nindefinidos, si contiene varios elementos del mismo valor\n"
                        + "no hay garantia de cual sera encontrado.\n"
                        + "Retorna el índice de la clave de búsqueda, si está contenido en el arreglo,\nde lo contrario, (-(punto de inserción)-1). El punto de inserción se define\n"
                        + "como el punto en el que la clave se insertaría en el arreglo:\nel índice del primer elemento mayor que la clave, o una longitud si todos\n"
                        + "los elementos del arreglo son menores que la clave especificada.\nTenga en cuenta que esto garantiza que el valor de retorno.\n"
                        + "será >= 0 si y solo si se encuentra la clave.\nEj: Arrays.bynarySearch(float[] a,int fromIndex,int toIndex,float key)");
                jLabel1.setText("static int");
                break;
            case "bynarySearch(int[] a,int key)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nBusca en el arreglo de por el valor espeficado usando el algoritmo\nde busqueda binaria, el arreglo debe estar ordenado antes\n"
                        + "de realizar la llamada a este metodo, de lo contrario los resultados son\nindefinidos, si contiene varios elementos del mismo valor\n"
                        + "no hay garantia de cual sera encontrado.\n"
                        + "Retorna el índice de la clave de búsqueda, si está contenido en el arreglo,\nde lo contrario, (-(punto de inserción)-1). El punto de inserción se define\n"
                        + "como el punto en el que la clave se insertaría en el arreglo:\nel índice del primer elemento mayor que la clave, o una longitud si todos\n"
                        + "los elementos del arreglo son menores que la clave especificada.\nTenga en cuenta que esto garantiza que el valor de retorno.\n"
                        + "será >= 0 si y solo si se encuentra la clave.\nEj: Arrays.bynarySearch(int[] a,int key)");
                jLabel1.setText("static int");
                break;
            case "bynarySearch(int a,int fromIndex,int toIndex,int key)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nBusca en el arreglo de por el valor espeficado usando el algoritmo\nde busqueda binaria, el rango debe estar ordenado antes\n"
                        + "de realizar la llamada a este metodo, de lo contrario los resultados son\nindefinidos, si contiene varios elementos del mismo valor\n"
                        + "no hay garantia de cual sera encontrado.\n"
                        + "Retorna el índice de la clave de búsqueda, si está contenido en el arreglo,\nde lo contrario, (-(punto de inserción)-1). El punto de inserción se define\n"
                        + "como el punto en el que la clave se insertaría en el arreglo:\nel índice del primer elemento mayor que la clave, o una longitud si todos\n"
                        + "los elementos del arreglo son menores que la clave especificada.\nTenga en cuenta que esto garantiza que el valor de retorno.\n"
                        + "será >= 0 si y solo si se encuentra la clave.\nEj: Arrays.bynarySearch(int a,int fromIndex,int toIndex,int key)");
                jLabel1.setText("static int");
                break;
            case "bynarySearch(long[]int fromIndex,int toIndex,long key)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nBusca en el arreglo de por el valor espeficado usando el algoritmo\nde busqueda binaria, el rango debe estar ordenado antes\n"
                        + "de realizar la llamada a este metodo, de lo contrario los resultados son\nindefinidos, si contiene varios elementos del mismo valor\n"
                        + "no hay garantia de cual sera encontrado.\n"
                        + "Retorna el índice de la clave de búsqueda, si está contenido en el arreglo,\nde lo contrario, (-(punto de inserción)-1). El punto de inserción se define\n"
                        + "como el punto en el que la clave se insertaría en el arreglo:\nel índice del primer elemento mayor que la clave, o una longitud si todos\n"
                        + "los elementos del arreglo son menores que la clave especificada.\nTenga en cuenta que esto garantiza que el valor de retorno.\n"
                        + "será >= 0 si y solo si se encuentra la clave.\nEj: Arrays.bynarySearch(long[]int fromIndex,int toIndex,long key)");
                jLabel1.setText("static int");
                break;
            case "bynarySearch(long[] a,long key)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nBusca en el arreglo de por el valor espeficado usando el algoritmo\nde busqueda binaria, el arreglo debe estar ordenado antes\n"
                        + "de realizar la llamada a este metodo, de lo contrario los resultados son\nindefinidos, si contiene varios elementos del mismo valor\n"
                        + "no hay garantia de cual sera encontrado.\n"
                        + "Retorna el índice de la clave de búsqueda, si está contenido en el arreglo,\nde lo contrario, (-(punto de inserción)-1). El punto de inserción se define\n"
                        + "como el punto en el que la clave se insertaría en el arreglo:\nel índice del primer elemento mayor que la clave, o una longitud si todos\n"
                        + "los elementos del arreglo son menores que la clave especificada.\nTenga en cuenta que esto garantiza que el valor de retorno.\n"
                        + "será >= 0 si y solo si se encuentra la clave.\nEj: Arrays.bynarySearch(long[] a,long key)");
                jLabel1.setText("static int");
                break;
            case "bynarySearch(Object[] a,int fromIndex,int toIndex,Object key)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nBusca en el arreglo de por el valor espeficado usando el algoritmo\nde busqueda binaria, el rango debe estar ordenado antes\n"
                        + "de realizar la llamada a este metodo, de lo contrario los resultados son\nindefinidos, si contiene varios elementos del mismo valor\n"
                        + "no hay garantia de cual sera encontrado.\n"
                        + "Retorna el índice de la clave de búsqueda, si está contenido en el arreglo,\nde lo contrario, (-(punto de inserción)-1). El punto de inserción se define\n"
                        + "como el punto en el que la clave se insertaría en el arreglo:\nel índice del primer elemento mayor que la clave, o una longitud si todos\n"
                        + "los elementos del arreglo son menores que la clave especificada.\nTenga en cuenta que esto garantiza que el valor de retorno.\n"
                        + "será >= 0 si y solo si se encuentra la clave.\nEj: Arrays.bynarySearch(Object[] a,int fromIndex,int toIndex,Object key)");
                jLabel1.setText("static int");
                break;
            case "bynarySearch(Object[] a,Object key)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nBusca en el arreglo de por el valor espeficado usando el algoritmo\nde busqueda binaria, el arreglo debe estar ordenado antes\n"
                        + "de realizar la llamada a este metodo, de lo contrario los resultados son\nindefinidos, si contiene varios elementos del mismo valor\n"
                        + "no hay garantia de cual sera encontrado.\n"
                        + "Retorna el índice de la clave de búsqueda, si está contenido en el arreglo,\nde lo contrario, (-(punto de inserción)-1). El punto de inserción se define\n"
                        + "como el punto en el que la clave se insertaría en el arreglo:\nel índice del primer elemento mayor que la clave, o una longitud si todos\n"
                        + "los elementos del arreglo son menores que la clave especificada.\nTenga en cuenta que esto garantiza que el valor de retorno.\n"
                        + "será >= 0 si y solo si se encuentra la clave.\nEj: Arrays.bynarySearch(Object[] a,Object key)");
                jLabel1.setText("static int");
                break;
            case "bynarySearch(short[] a,int fromIndex,int toIndex,short key)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nBusca en el arreglo de por el valor espeficado usando el algoritmo\nde busqueda binaria, el rango debe estar ordenado antes\n"
                        + "de realizar la llamada a este metodo, de lo contrario los resultados son\nindefinidos, si contiene varios elementos del mismo valor\n"
                        + "no hay garantia de cual sera encontrado.\n"
                        + "Retorna el índice de la clave de búsqueda, si está contenido en el arreglo,\nde lo contrario, (-(punto de inserción)-1). El punto de inserción se define\n"
                        + "como el punto en el que la clave se insertaría en el arreglo:\nel índice del primer elemento mayor que la clave, o una longitud si todos\n"
                        + "los elementos del arreglo son menores que la clave especificada.\nTenga en cuenta que esto garantiza que el valor de retorno.\n"
                        + "será >= 0 si y solo si se encuentra la clave.\nEj: Arrays.bynarySearch(short[] a,int fromIndex,int toIndex,short key)");
                jLabel1.setText("static int");
                break;
            case "bynarySearch(short[] a,short key)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nBusca en el arreglo de por el valor espeficado usando el algoritmo\nde busqueda binaria, el arreglo debe estar ordenado antes\n"
                        + "de realizar la llamada a este metodo, de lo contrario los resultados son\nindefinidos, si contiene varios elementos del mismo valor\n"
                        + "no hay garantia de cual sera encontrado.\n"
                        + "Retorna el índice de la clave de búsqueda, si está contenido en el arreglo,\nde lo contrario, (-(punto de inserción)-1). El punto de inserción se define\n"
                        + "como el punto en el que la clave se insertaría en el arreglo:\nel índice del primer elemento mayor que la clave, o una longitud si todos\n"
                        + "los elementos del arreglo son menores que la clave especificada.\nTenga en cuenta que esto garantiza que el valor de retorno.\n"
                        + "será >= 0 si y solo si se encuentra la clave.\nEj: Arrays.bynarySearch(short[] a,short key)");
                jLabel1.setText("static int");
                break;
            case "copyOf(boolean[] original,int newLength)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nCopia el arreglo truncando o llenando de false (si es necesario)\npara que tenga el tamaño especificado.\nEj: Arrays.copyOf(boolean[] original,int newLength)");
                jLabel1.setText("static boolean[]");
                break;
            case "copyOf(byte[] original,int newLength)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nCopia el arreglo truncando o llenando de ceros (si es necesario)\npara que tenga el tamaño especificado.\nEj: Arrays.copyOf(byte[] original,int newLength)");
                jLabel1.setText("static byte[]");
                break;
            case "copyOf(char[] original,int newLength)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nCopia el arreglo truncando o llenando de caracteres null (si es necesario)\npara que tenga el tamaño especificado.\nEj: Arrays.copyOf(char[] original,int newLength)");
                jLabel1.setText("static char[]");
                break;
            case "copyOf(double[] original,int newLength)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nCopia el arreglo truncando o llenando de ceros (si es necesario)\npara que tenga el tamaño especificado.\nEj: Arrays.copyOf(double[] original,int newLength)");
                jLabel1.setText("static double[]");
                break;
            case "copyOf(float[] original,int newLength)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nCopia el arreglo truncando o llenando de ceros (si es necesario)\npara que tenga el tamaño especificado.\nEj: Arrays.copyOf(float[] original,int newLength)");
                jLabel1.setText("static float[]");
                break;
            case "copyOf(int[] original,int newLength)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nCopia el arreglo truncando o llenando de ceros (si es necesario)\npara que tenga el tamaño especificado.\nEj: Arrays.copyOf(int[] original,int newLength)");
                jLabel1.setText("static int[]");
                break;
            case "copyOf(long[] original,int newLength)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nCopia el arreglo truncando o llenando de ceros (si es necesario)\npara que tenga el tamaño especificado.\nEj: Arrays.copyOf(long[] original,int newLength)");
                jLabel1.setText("static long[]");
                break;
            case "copyOf(short[] original,int newLength)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nCopia el arreglo truncando o llenando de ceros (si es necesario)\npara que tenga el tamaño especificado.\nEj: Arrays.copyOf(short[] original,int newLength)");
                jLabel1.setText("static short[]");
                break;
            case "copyOf(T[] original,int newLength)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nCopia el arreglo truncando o llenando de nulls (si es necesario)\npara que tenga el tamaño especificado.\nEj: Arrays.copyOf(T[] original,int newLength)");
                jLabel1.setText("static <T> T[]");
                break;
            case "copyOfRange(boolean[] original,int from,int to)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nCopia el rango especificado del arreglo en un nuevo arreglo.\nEj: Arrays.copyOfRange(boolean[] original,int from,int to)");
                jLabel1.setText("static boolean[]");
                break;
            case "copyOfRange(byte[] original,,int from,int to)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nCopia el rango especificado del arreglo en un nuevo arreglo.\nEj: Arrays.copyOfRange(byte[] original,int from,int to)");
                jLabel1.setText("static byte[]");
                break;
            case "copyOfRange(char[] original,,int from,int to)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nCopia el rango especificado del arreglo en un nuevo arreglo.\nEj: Arrays.copyOfRange(char[] original,int from,int to)");
                jLabel1.setText("static char[]");
                break;
            case "copyOfRange(double[] original,,int from,int to)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nCopia el rango especificado del arreglo en un nuevo arreglo.\nEj: Arrays.copyOfRange(double[] original,int from,int to)");
                jLabel1.setText("static double[]");
                break;
            case "copyOfRange(float[] original,,int from,int to)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nCopia el rango especificado del arreglo en un nuevo arreglo.\nEj: Arrays.copyOfRange(float[] original,int from,int to)");
                jLabel1.setText("static float[]");
                break;
            case "copyOfRange(int[] original,,int from,int to)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nCopia el rango especificado del arreglo en un nuevo arreglo.\nEj: Arrays.copyOfRange(int[] original,int from,int to)");
                jLabel1.setText("static int[]");
                break;
            case "copyOfRange(long[] original,,int from,int to)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nCopia el rango especificado del arreglo en un nuevo arreglo.\nEj: Arrays.copyOfRange(long[] original,int from,int to)");
                jLabel1.setText("static long[]");
                break;
            case "copyOfRange(short[] original,int from,int to)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nCopia el rango especificado del arreglo en un nuevo arreglo.\nEj: Arrays.copyOfRange(short[] original,int from,int to)");
                jLabel1.setText("static short[]");
                break;
            case "copyOfRange(T[] original,,int from,int to)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nCopia el rango especificado del arreglo en un nuevo arreglo.\nEj: Arrays.copyOfRange(T[] original,int from,int to)");
                jLabel1.setText("static <T> T[]");
                break;
            case "deepEquals(Object[] a1,Object[] a2)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna true si y solo si ambos arreglos son \"profundamente\" iguales entre si.\nEj: Arrays.deepEquals(Object[] a1,Object[] a2)");
                jLabel1.setText("static boolean");
                break;
            case "equals(boolean[] a,boolean[] a2)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna true si y solo si ambos arreglos de boolean son iguales.\nEj: Arrays.equals(boolean[] a,boolean[] a2)");
                jLabel1.setText("static boolean");
                break;
            case "equals(byte[] a,byte[] a2)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna true si y solo si ambos arreglos de bytes son iguales.\nEj: Arrays.equals(byte[] a,byte[] a2)");
                jLabel1.setText("static boolean");
                break;
            case "equals(char[] a,char[] a2)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna true si y solo si ambos arreglos de chars son iguales.\nEj: Arrays.equals(char[] a,char[] a2)");
                jLabel1.setText("static boolean");
                break;
            case "equals(double[] a,double[] a2)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna true si y solo si ambos arreglos de doubles son iguales.\nEj: Arrays.equals(double[] a,double[] a2)");
                jLabel1.setText("static boolean");
                break;
            case "equals(float[] a,float[] a2)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna true si y solo si ambos arreglos de floats son iguales.\nEj: Arrays.equals(float[] a,float[] a2)");
                jLabel1.setText("static boolean");
                break;
            case "equals(int[] a,int[] a2)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna true si y solo si ambos arreglos de ints son iguales.\nEj: Arrays.equals(int[] a,int[] a2)");
                jLabel1.setText("static boolean");
                break;
            case "equals(long[] a,long[] a2)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna true si y solo si ambos arreglos de longs son iguales.\nEj: Arrays.equals(long[] a,long[] a2)");
                jLabel1.setText("static boolean");
                break;
            case "equals(Object[] a,Object[] a2)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna true si y solo si ambos arreglos de Objects son iguales.\nEj: Arrays.equals(Object[] a,Object[] a2)");
                jLabel1.setText("static boolean");
                break;
            case "equals(short[] a,short[] a2)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna true si y solo si ambos arreglos de shorts son iguales.\nEj: Arrays.equals(short[] a,short[] a2)");
                jLabel1.setText("static boolean");
                break;
            case "fill(boolean[] a,boolean val)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nAsigna el valor boolean especificado a cada elemento del arreglo de booleans.\nEj: Arrays.fill(boolean[] a,boolean val)");
                jLabel1.setText("static void");
                break;
            case "fill(boolean[] a,int fromIndex,int toIndex,boolean val)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nAsigna el valor boolean especificado a cada elemento dentro el rango\ndel arreglo de booleans.\nEj: Arrays.fill(boolean[] a,int fromIndex,int toIndex,boolean val)");
                jLabel1.setText("static void");
                break;
            case "fill(byte[] a,byte val)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nAsigna el valor byte especificado a cada elemento del arreglo de bytes.\nEj: Arrays.fill(byte[] a,byte val)");
                jLabel1.setText("static void");
                break;
            case "fill(byte[] a,int fromIndex,int toIndex,byte val)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nAsigna el valor byte especificado a cada elemento dentro el rango\ndel arreglo de bytes.\nEj: Arrays.fill(byte[] a,int fromIndex,int toIndex,byte val)");
                jLabel1.setText("static void");
                break;
            case "fill(char[] a,char val)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nAsigna el valor char especificado a cada elemento del arreglo de chars.\nEj: Arrays.fill(char[] a,char val)");
                jLabel1.setText("static void");
                break;
            case "fill(char[] a,int fromIndex,int toIndex,char val)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nAsigna el valor char especificado a cada elemento dentro el rango\ndel arreglo de chars.\nEj: Arrays.fill(char[] a,int fromIndex,int toIndex,char val)");
                jLabel1.setText("static void");
                break;
            case "fill(double[] a,double val)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nAsigna el valor double especificado a cada elemento del arreglo de doubles.\nEj: Arrays.fill(double[] a,double val");
                jLabel1.setText("static void");
                break;
            case "fill(double[] a,int fromIndex,int toIndex,double val)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nAsigna el valor double especificado a cada elemento dentro el rango\ndel arreglo de doubles.\nEj: Arrays.fill(double[] a,int fromIndex,int toIndex,double val)");
                jLabel1.setText("static void");
                break;
            case "fill(float[] a,float val)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nAsigna el valor float especificado a cada elemento del arreglo de floats.\nEj: Arrays.fill(float[] a,float val)");
                jLabel1.setText("static void");
                break;
            case "fill(float[] a,int fromIndex,int toIndex,float val)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nAsigna el valor float especificado a cada elemento dentro el rango\ndel arreglo de floats.\nEj: Arrays.fill(float[] a,int fromIndex,int toIndex,float val)");
                jLabel1.setText("static void");
                break;
            case "fill(int[] a,int val)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nAsigna el valor int especificado a cada elemento del arreglo de ints.\nEj: Arrays.fill(int[] a,int val)");
                jLabel1.setText("static void");
                break;
            case "fill(int[] a,int fromIndex,int toIndex,int val)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nAsigna el valor int especificado a cada elemento dentro el rango\ndel arreglo de ints.\nEj: Arrays.fill(int[] a,int fromIndex,int toIndex,int val)");
                jLabel1.setText("static void");
                break;
            case "fill(long[] a,int fromIndex,int toIndex,long val)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nAsigna el valor long especificado a cada elemento dentro el rango\ndel arreglo de longs.\nEj: Arrays.fill(long[] a,int fromIndex,int toIndex,long val)");
                jLabel1.setText("static void");
                break;
            case "fill(long[] a,long val)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nAsigna el valor long especificado a cada elemento del arreglo de longs.\nEj: Arrays.fill(long[] a,long val)");
                jLabel1.setText("static void");
                break;
            case "fill(Object[] a,int fromIndex,int toIndex,Object val)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nAsigna el valor Object especificado a cada elemento dentro el rango\ndel arreglo de Objects.\nEj: Arrays.fill(Object[] a,int fromIndex,int toIndex,Object val)");
                jLabel1.setText("static void");
                break;
            case "fill(Object[] a,Object val)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nAsigna el valor Object especificado a cada elemento del arreglo de Objects.\nEj: Arrays.fill(Object[] a,Object val)");
                jLabel1.setText("static void");
                break;
            case "fill(short[] a,int fromIndex,int toIndex,short val)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nAsigna el valor short especificado a cada elemento dentro el rango\ndel arreglo de shorts.\nEj: Arrays.fill(short[] a,int fromIndex,int toIndex,short val)");
                jLabel1.setText("static void");
                break;
            case "fill(short[] a,short val)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nAsigna el valor short especificado a cada elemento del arreglo de shorts.\nEj: Arrays.fill(short[] a,short val)");
                jLabel1.setText("static void");
                break;
            case "parallelSort(byte[] a)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nOrdena el arreglo especificado en orden ascendente.\nEste metodo es mucho mas eficiente para arreglos muy grandes ( >10000)\n"
                        + "ya que se ejecuta en varios hilos paralelamente, su eficencia tambien esta\nligada a la cantidad de nucleos que tenga el procesador.\n"
                        + "Si no se tiene la necesidad especifica de usarlo, usar el metodo sort()\nel cual es mas eficiente con arreglos mas pequeños.\nEj: Arrays.parallelSort(byte[] a)");
                jLabel1.setText("static void");
                break;
            case "parallelSort(byte[] a,int fromIndex,int toIndex)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nOrdena el arreglo especificado en orden ascendente.\nEste metodo es mucho mas eficiente para arreglos muy grandes ( >10000)\n"
                        + "ya que se ejecuta en varios hilos paralelamente, su eficencia tambien esta\nligada a la cantidad de nucleos que tenga el procesador.\n"
                        + "Si no se tiene la necesidad especifica de usarlo, usar el metodo sort()\nel cual es mas eficiente con arreglos mas pequeños.\nEj: Arrays.parallelSort(byte[] a,int fromIndex,int toIndex)");
                jLabel1.setText("static void");
                break;
            case "parallelSort(char[] a)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nOrdena el arreglo especificado en orden ascendente.\nEste metodo es mucho mas eficiente para arreglos muy grandes ( >10000)\n"
                        + "ya que se ejecuta en varios hilos paralelamente, su eficencia tambien esta\nligada a la cantidad de nucleos que tenga el procesador.\n"
                        + "Si no se tiene la necesidad especifica de usarlo, usar el metodo sort()\nel cual es mas eficiente con arreglos mas pequeños.\nEj: Arrays.parallelSort(char[] a)");
                jLabel1.setText("static void");
                break;
            case "parallelSort(char[] a,int fromIndex,int toIndex)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nOrdena el arreglo especificado en orden ascendente.\nEste metodo es mucho mas eficiente para arreglos muy grandes ( >10000)\n"
                        + "ya que se ejecuta en varios hilos paralelamente, su eficencia tambien esta\nligada a la cantidad de nucleos que tenga el procesador.\n"
                        + "Si no se tiene la necesidad especifica de usarlo, usar el metodo sort()\nel cual es mas eficiente con arreglos mas pequeños.\nEj: Arrays.parallelSort(char[] a,int fromIndex,int toIndex)");
                jLabel1.setText("static void");
                break;
            case "parallelSort(double[] a)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nOrdena el arreglo especificado en orden ascendente.\nEste metodo es mucho mas eficiente para arreglos muy grandes ( >10000)\n"
                        + "ya que se ejecuta en varios hilos paralelamente, su eficencia tambien esta\nligada a la cantidad de nucleos que tenga el procesador.\n"
                        + "Si no se tiene la necesidad especifica de usarlo, usar el metodo sort()\nel cual es mas eficiente con arreglos mas pequeños.\nEj: Arrays.parallelSort(double[] a)");
                jLabel1.setText("static void");
                break;
            case "parallelSort(double[] a,int fromIndex,int toIndex)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nOrdena el arreglo especificado en orden ascendente.\nEste metodo es mucho mas eficiente para arreglos muy grandes ( >10000)\n"
                        + "ya que se ejecuta en varios hilos paralelamente, su eficencia tambien esta\nligada a la cantidad de nucleos que tenga el procesador.\n"
                        + "Si no se tiene la necesidad especifica de usarlo, usar el metodo sort()\nel cual es mas eficiente con arreglos mas pequeños.\nEj: Arrays.parallelSort(double[] a,int fromIndex,int toIndex)");
                jLabel1.setText("static void");
                break;
            case "parallelSort(float[] a)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nOrdena el arreglo especificado en orden ascendente.\nEste metodo es mucho mas eficiente para arreglos muy grandes ( >10000)\n"
                        + "ya que se ejecuta en varios hilos paralelamente, su eficencia tambien esta\nligada a la cantidad de nucleos que tenga el procesador.\n"
                        + "Si no se tiene la necesidad especifica de usarlo, usar el metodo sort()\nel cual es mas eficiente con arreglos mas pequeños.\nEj: Arrays.parallelSort(float[] a)");
                jLabel1.setText("static void");
                break;
            case "parallelSort(float[] a,int fromIndex,int toIndex)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nOrdena el arreglo especificado en orden ascendente.\nEste metodo es mucho mas eficiente para arreglos muy grandes ( >10000)\n"
                        + "ya que se ejecuta en varios hilos paralelamente, su eficencia tambien esta\nligada a la cantidad de nucleos que tenga el procesador.\n"
                        + "Si no se tiene la necesidad especifica de usarlo, usar el metodo sort()\nel cual es mas eficiente con arreglos mas pequeños.\nEj: Arrays.parallelSort(float[] a,int fromIndex,int toIndex)");
                jLabel1.setText("static void");
                break;
            case "parallelSort(int[] a)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nOrdena el arreglo especificado en orden ascendente.\nEste metodo es mucho mas eficiente para arreglos muy grandes ( >10000)\n"
                        + "ya que se ejecuta en varios hilos paralelamente, su eficencia tambien esta\nligada a la cantidad de nucleos que tenga el procesador.\n"
                        + "Si no se tiene la necesidad especifica de usarlo, usar el metodo sort()\nel cual es mas eficiente con arreglos mas pequeños.\nEj: Arrays.parallelSort(int[] a)");
                jLabel1.setText("static void");
                break;
            case "parallelSort(int[] a,int fromIndex,int toIndex)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nOrdena el arreglo especificado en orden ascendente.\nEste metodo es mucho mas eficiente para arreglos muy grandes ( >10000)\n"
                        + "ya que se ejecuta en varios hilos paralelamente, su eficencia tambien esta\nligada a la cantidad de nucleos que tenga el procesador.\n"
                        + "Si no se tiene la necesidad especifica de usarlo, usar el metodo sort()\nel cual es mas eficiente con arreglos mas pequeños.\nEj: Arrays.parallelSort(int[] a,int fromIndex,int toIndex)");
                jLabel1.setText("static void");
                break;
            case "parallelSort(long[] a)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nOrdena el arreglo especificado en orden ascendente.\nEste metodo es mucho mas eficiente para arreglos muy grandes ( >10000)\n"
                        + "ya que se ejecuta en varios hilos paralelamente, su eficencia tambien esta\nligada a la cantidad de nucleos que tenga el procesador.\n"
                        + "Si no se tiene la necesidad especifica de usarlo, usar el metodo sort()\nel cual es mas eficiente con arreglos mas pequeños.\nEj: Arrays.parallelSort(long[] a)");
                jLabel1.setText("static void");
                break;
            case "parallelSort(long[] a,int fromIndex,int toIndex)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nOrdena el arreglo especificado en orden ascendente.\nEste metodo es mucho mas eficiente para arreglos muy grandes ( >10000)\n"
                        + "ya que se ejecuta en varios hilos paralelamente, su eficencia tambien esta\nligada a la cantidad de nucleos que tenga el procesador.\n"
                        + "Si no se tiene la necesidad especifica de usarlo, usar el metodo sort()\nel cual es mas eficiente con arreglos mas pequeños.\nEj: Arrays.parallelSort(long[] a,int fromIndex,int toIndex)");
                jLabel1.setText("static void");
                break;
            case "parallelSort(Object[] a)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nOrdena el arreglo especificado en orden ascendente.\nEste metodo es mucho mas eficiente para arreglos muy grandes ( >10000)\n"
                        + "ya que se ejecuta en varios hilos paralelamente, su eficencia tambien esta\nligada a la cantidad de nucleos que tenga el procesador.\n"
                        + "Si no se tiene la necesidad especifica de usarlo, usar el metodo sort()\nel cual es mas eficiente con arreglos mas pequeños.\nEj: Arrays.parallelSort(Object[] a)");
                jLabel1.setText("static void");
                break;
            case "parallelSort(Object[] a,int fromIndex,int toIndex)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nOrdena el arreglo especificado en orden ascendente.\nEste metodo es mucho mas eficiente para arreglos muy grandes ( >10000)\n"
                        + "ya que se ejecuta en varios hilos paralelamente, su eficencia tambien esta\nligada a la cantidad de nucleos que tenga el procesador.\n"
                        + "Si no se tiene la necesidad especifica de usarlo, usar el metodo sort()\nel cual es mas eficiente con arreglos mas pequeños.\nEj: Arrays.parallelSort(Object[] a,int fromIndex,int toIndex)");
                jLabel1.setText("static void");
                break;
            case "parallelSort(short[] a)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nOrdena el arreglo especificado en orden ascendente.\nEste metodo es mucho mas eficiente para arreglos muy grandes ( >10000)\n"
                        + "ya que se ejecuta en varios hilos paralelamente, su eficencia tambien esta\nligada a la cantidad de nucleos que tenga el procesador.\n"
                        + "Si no se tiene la necesidad especifica de usarlo, usar el metodo sort()\nel cual es mas eficiente con arreglos mas pequeños.\nEj: Arrays.parallelSort(short[] a)");
                jLabel1.setText("static void");
                break;
            case "parallelSort(short[] a,int fromIndex,int toIndex)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nOrdena el arreglo especificado en orden ascendente.\nEste metodo es mucho mas eficiente para arreglos muy grandes ( >10000)\n"
                        + "ya que se ejecuta en varios hilos paralelamente, su eficencia tambien esta\nligada a la cantidad de nucleos que tenga el procesador.\n"
                        + "Si no se tiene la necesidad especifica de usarlo, usar el metodo sort()\nel cual es mas eficiente con arreglos mas pequeños.\nEj: Arrays.parallelSort(short[] a,int fromIndex,int toIndex)");
                jLabel1.setText("static void");
                break;
            case "sort(byte[] a)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nOrdena el arreglo especificado en orden ascendente.\nEj: Arrays.sort(byte[] a)");
                jLabel1.setText("static void");
                break;
            case "sort(byte[] a,int fromIndex,int toIndex)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nOrdena el rango especificado del arreglo en orden ascendente.\nEj: Arrays.sort(byte[] a,int fromIndex,int toIndex)");
                jLabel1.setText("static void");
                break;
            case "sort(char[] a)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nOrdena el arreglo especificado en orden ascendente.\nEj: Arrays.sort(char[] a)");
                jLabel1.setText("static void");
                break;
            case "sort(char[] a,int fromIndex,int toIndex)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nOrdena el rango especificado del arreglo en orden ascendente.\nEj: Arrays.sort(char[] a,int fromIndex,int toIndex)");
                jLabel1.setText("static void");
                break;
            case "sort(double[] a)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nOrdena el arreglo especificado en orden ascendente.\nEj: Arrays.sort(double[] a)");
                jLabel1.setText("static void");
                break;
            case "sort(double[] a,int fromIndex,int toIndex)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nOrdena el rango especificado del arreglo en orden ascendente.\nEj: Arrays.sort(double[] a,int fromIndex,int toIndex)");
                jLabel1.setText("static void");
                break;
            case "sort(float[] a)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nOrdena el arreglo especificado en orden ascendente.\nEj: Arrays.sort(float[] a)");
                jLabel1.setText("static void");
                break;
            case "sort(float[] a,int fromIndex,int toIndex)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nOrdena el rango especificado del arreglo en orden ascendente.\nEj: Arrays.sort(float[] a,int fromIndex,int toIndex)");
                jLabel1.setText("static void");
                break;
            case "sort(int[] a)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nOrdena el arreglo especificado en orden ascendente.\nEj: Arrays.sort(int[] a)");
                jLabel1.setText("static void");
                break;
            case "sort(int[] a,int fromIndex,int toIndex)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nOrdena el rango especificado del arreglo en orden ascendente.\nEj: Arrays.sort(int[] a,int fromIndex,int toIndex)");
                jLabel1.setText("static void");
                break;
            case "sort(long[] a)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nOrdena el arreglo especificado en orden ascendente.\nEj: Arrays.sort(long[] a)");
                jLabel1.setText("static void");
                break;
            case "sort(long[] a,int fromIndex,int toIndex)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nOrdena el rango especificado del arreglo en orden ascendente.\nEj: Arrays.sort(long[] a,int fromIndex,int toIndex)");
                jLabel1.setText("static void");
                break;
            case "sort(Object[] a)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nOrdena el arreglo especificado en orden ascendente.\nEj: Arrays.sort(Object[] a)");
                jLabel1.setText("static void");
                break;
            case "sort(Object[] a,int fromIndex,int toIndex)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nOrdena el rango especificado del arreglo en orden ascendente.\nEj: Arrays.sort(Object[] a,int fromIndex,int toIndex)");
                jLabel1.setText("static void");
                break;
            case "sort(short[] a)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nOrdena el arreglo especificado en orden ascendente.\nEj: Arrays.sort(short[] a)");
                jLabel1.setText("static void");
                break;
            case "sort(short[] a,int fromIndex,int toIndex)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nOrdena el rango especificado del arreglo en orden ascendente.\nEj: Arrays.sort(short[] a,int fromIndex,int toIndex)");
                jLabel1.setText("static void");
                break;
            case "toString(boolean[] a)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna un representacion en String de los contenidos del arreglo.\nEj: Arrays.toString(boolean[] a)");
                jLabel1.setText("static String");
                break;
            case "toString(byte[] a)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna un representacion en String de los contenidos del arreglo.\nEj: Arrays.toString(byte[] a)");
                jLabel1.setText("static String");
                break;
            case "toString(char[] a)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna un representacion en String de los contenidos del arreglo.\nEj: Arrays.toString(char[] a)");
                jLabel1.setText("static String");
                break;
            case "toString(double[] a)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna un representacion en String de los contenidos del arreglo.\nEj: Arrays.toString(double[] a)");
                jLabel1.setText("static String");
                break;
            case "toString(float[] a)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna un representacion en String de los contenidos del arreglo.\nEj: Arrays.toString(float[] a)");
                jLabel1.setText("static String");
                break;
            case "toString(int[] a)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna un representacion en String de los contenidos del arreglo.\nEj: Arrays.toString(int[] a)");
                jLabel1.setText("static String");
                break;
            case "toString(long[] a)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna un representacion en String de los contenidos del arreglo.\nEj: Arrays.toString(long[] a)");
                jLabel1.setText("static String");
                break;
            case "toString(Object[] a)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna un representacion en String de los contenidos del arreglo.\nEj: Arrays.toString(Object[] a)");
                jLabel1.setText("static String");
                break;
            case "toString(short[] a)":
                jTextArea1.setText("");
                jTextArea1.append("Metodo Estatico\nRetorna un representacion en String de los contenidos del arreglo.\nEj: Arrays.toString(short[] a)");
                jLabel1.setText("static String");
                break;
        }
    }

    /**
     * Metodo void que muestra la version actual y el registro de cambios.
     */
    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        // TODO add your handling code here:
        javax.swing.JOptionPane.showMessageDialog(this, "Versión " + ver + ":\njava.lang. (Clases basicas) añadido.\njava.util. (Arrays y ArrayList) añadido.\nRev 0.1: Documentacion y orden", "Versión", javax.swing.JOptionPane.PLAIN_MESSAGE);
    }//GEN-LAST:event_jButton1ActionPerformed

    /**
     * Metodo void que muestra un mensaje dedicado a la persona para quien fue
     * realizado este proyecto.
     */
    private void jButton2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton2ActionPerformed
        // TODO add your handling code here:
        javax.swing.JOptionPane.showMessageDialog(this, "Como regalo y premio por todo tu esfuerzo pandita ^~^\nEspero que te sirva.\nCon cariño: Brayan", "Mensaje para ti", javax.swing.JOptionPane.PLAIN_MESSAGE);
    }//GEN-LAST:event_jButton2ActionPerformed

    /**
     * Selecciona una imagen en la ruta dada para asignarla como icono del
     * JFrame.
     *
     * @return - La imagen especificada.
     */
    @Override
    public Image getIconImage() {
        Image retValue = Toolkit.getDefaultToolkit().
                getImage(ClassLoader.getSystemResource("panda-icon.png"));
        return retValue;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Ventana.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(() -> {
            new Ventana().setVisible(true);
        });

    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton1;
    private javax.swing.JButton jButton2;
    private javax.swing.JComboBox<String> jComboBox1;
    private javax.swing.JComboBox<String> jComboBox2;
    private javax.swing.JComboBox<String> jComboBox3;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTextArea jTextArea1;
    // End of variables declaration//GEN-END:variables
}
